package tests

import (
	"context"
	"fmt"
	"log"
	"net"
	"os"
	"strings"
	"time"

	ingressnodefwv1alpha1 "github.com/openshift/ingress-node-firewall/api/v1alpha1"
	"github.com/openshift/ingress-node-firewall/pkg/failsaferules"
	infmetrics "github.com/openshift/ingress-node-firewall/pkg/metrics"
	inftestconsts "github.com/openshift/ingress-node-firewall/test/consts"
	testclient "github.com/openshift/ingress-node-firewall/test/e2e/client"
	"github.com/openshift/ingress-node-firewall/test/e2e/daemonset"
	"github.com/openshift/ingress-node-firewall/test/e2e/deployment"
	"github.com/openshift/ingress-node-firewall/test/e2e/events"
	"github.com/openshift/ingress-node-firewall/test/e2e/exec"
	"github.com/openshift/ingress-node-firewall/test/e2e/icmp"
	infwutils "github.com/openshift/ingress-node-firewall/test/e2e/ingress-node-firewall"
	"github.com/openshift/ingress-node-firewall/test/e2e/node"
	"github.com/openshift/ingress-node-firewall/test/e2e/pods"
	"github.com/openshift/ingress-node-firewall/test/e2e/transport"

	. "github.com/onsi/ginkgo"
	. "github.com/onsi/gomega"
	prommodel "github.com/prometheus/common/model"
	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/wait"
	"k8s.io/component-base/metrics/testutil"
	goclient "sigs.k8s.io/controller-runtime/pkg/client"
)

var (
	OperatorNameSpace        = inftestconsts.DefaultOperatorNameSpace
	retryInterval            = time.Millisecond * 10
	timeout                  = time.Second * 40
	testInterface            = "eth0"
	sctpEnabled              = false
	isSingleStack            = false
	v4Enabled                = false
	v6Enabled                = false
	v4SubnetLen              = "32"
	v6SubnetLen              = "128"
	testArtifactsLabelKey    = "e2e-inf-test"
	testArtifactsLabelValue  = ""
	testArtifactsLabelMap    = map[string]string{testArtifactsLabelKey: testArtifactsLabelValue}
	testArtifactsLabelString = fmt.Sprintf("%s=%s", testArtifactsLabelKey, testArtifactsLabelValue)
)

// testIngressNodeFirewall represents one IngressNodeFirewall object and is used to generate the sourceCIDRs and protocol
// rules.
type testIngressNodeFirewall struct {
	interfaces []string
	testRules  []testRule
}

// testRule is used as a template to generate sourceCIDRs entries and protocol rules
type testRule struct {
	// sourceCIDRsEntry is used to generate an INFs ingress rule sourceCIDRs. The number of entries equals the number of
	// sourceCIDRs created. It must contain at least one pod name source which IPV4 and IPV6 CIDRs are generated.
	sourceCIDRsEntries []sourceCIDRsEntry
	// protoRules is a list of funcs that return a proto rule for an INFs ingress rule.
	// These funcs serves as templates to generate rules for one or more protocols.
	// The list of protocols passed to the function depends on the test description.
	// Order is generated by the test harness to be unique for a source CIDR.
	protoRules []func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule
}

// sourceCIDRsEntry is used to generate a sourceCIDR for an INF ingress rule
// For example, if a given podName pods IPV4 address ends up being 172.168.1.8 with a v4CIDRPrefix of 24, then the generated
// sourceCIDR for IPV4 will be 172.168.1.0/24. In order to ensure IPV6 test coverage, its mandatory to also define
// v6CIDRPrefix.
type sourceCIDRsEntry struct {
	podName      string
	v4CIDRPrefix string
	v6CIDRPrefix string
}

// reachable is used by the test code to determine what connectivity we expect or not expect.
type reachable struct {
	// source defines the pod name which is the client in all test scenarios. Packets are generated source this client.
	source string
	// destination defines the pod name which is the server in all test scenarios. Packets are terminated for transport protocol
	// test cases. For ICMP protocol test cases, "destination" pod is used to set up networking and the server does nothing.
	destination string
	// port is used only for transport protocol tests and is ignored for ICMP test cases
	port string
	// connectivity informs the test code what connectivity we expect during the test case
	connectivity bool
}

func init() {
	if ns := os.Getenv("OO_INSTALL_NAMESPACE"); len(ns) != 0 {
		OperatorNameSpace = ns
	}
	if iss := os.Getenv("IS_SINGLESTACK"); len(iss) != 0 {
		if strings.ToLower(iss) == "true" {
			isSingleStack = true
		}
	}

	if intf := os.Getenv("NODE_INTERFACE"); len(intf) != 0 {
		testInterface = intf
	}
	if isSCTPEnabled := os.Getenv("ENABLE_SCTP"); len(isSCTPEnabled) != 0 {
		if strings.ToLower(isSCTPEnabled) == "true" {
			log.Println("SCTP tests are enabled")
			sctpEnabled = true
		}
	}

	v4Enabled = node.IPV4NetworkExists(testclient.Client, timeout)
	v6Enabled = node.IPV6NetworkExists(testclient.Client, timeout)
	if !v4Enabled && !v6Enabled {
		panic("Unable to detect if cluster is IPV4 or IPV6")
	}
}

var _ = Describe("Ingress Node Firewall", func() {
	// Because we don't fully use BeforeAll / AfterAll to setup/teardown test infrastructure and if an error or interrupt occurs,
	// we ensure a clean cluster using AfterSuite. This normally is a no-op and is only valid when user sends interrupt or test failure.
	AfterSuite(func() {
		Expect(pods.EnsureDeletedWithLabel(testclient.Client, OperatorNameSpace, testArtifactsLabelString, retryInterval, timeout)).Should(Succeed())
		Expect(infwutils.DeleteIngressNodeFirewallsWithLabels(testclient.Client, OperatorNameSpace,
			testArtifactsLabelString, timeout)).Should(Succeed())
	})

	Context("IngressNodeFirewall", func() {
		var (
			config             *ingressnodefwv1alpha1.IngressNodeFirewallConfig
			serverOnePort      = "80"
			allowedPort        = "40000"
			serverTwoPort      = "8080"
			serverOnePortRange = "79-81"
			clientOnePodName   = "e2e-inf-client-one"
			clientTwoPodName   = "e2e-inf-client-two"
			clientThreePodName = "e2e-inf-client-three"
			clientFourPodName  = "e2e-inf-client-four"
			serverOnePodName   = "e2e-inf-server-one"
			serverTwoPodName   = "e2e-inf-server-two"
			serverLabelKey     = "e2e-inf-server"
			serverLabelValue   = ""
			serverPodLabel     = map[string]string{serverLabelKey: serverLabelValue, testArtifactsLabelKey: testArtifactsLabelValue}
			clientLabelKey     = "e2e-inf-client"
			clientLabelValue   = ""
			clientPodLabel     = map[string]string{clientLabelKey: clientLabelValue, testArtifactsLabelKey: testArtifactsLabelValue}
			// SCTP is conditional added to this list depending on an environment variable
			transportProtocols = []ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType{ingressnodefwv1alpha1.ProtocolTypeTCP, ingressnodefwv1alpha1.ProtocolTypeUDP}
			icmpProtocols      = []ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType{ingressnodefwv1alpha1.ProtocolTypeICMP}
		)

		if sctpEnabled {
			transportProtocols = append(transportProtocols, ingressnodefwv1alpha1.ProtocolTypeSCTP)
		}

		if !isSingleStack {
			icmpProtocols = append(icmpProtocols, ingressnodefwv1alpha1.ProtocolTypeICMP6)
		}

		// We test IngressNodeFirewall configuration against pod to pod communication in a cluster, that is, our source CIDRs
		// must be a subset of the pod network CIDR.
		// The reason we are testing pod to pod communication, which isn't a typical use case for INF,
		// is to minimise possibility of cluster disruption during test runs, and it also gives us flexibility to create
		// (and disrupt) as many connections as we wish - only limited by the number of pods we can create.
		// For a KinD cluster, pod to pod communication is simple and the pod IPs can be filtered on the primary interface 'eth0'.
		// For OCP, pod IPs are visible on the GENEVE interface (with OVN-Kubernetes as the CNI) or vlan interface (with Openshift-SDN as the CNI).
		// This is where we want to attach our XDP program and perform filtering.
		// For OCP with OVN-Kubernetes as the CNI, the interface name is always 'genev_sys_6081'.
		// Test cases involve a source and destination. For all test cases, firewalling is assumed at the destinations node.
		table := []struct {
			it string
			// testINFs is a list of testRules which represent INF rules. A ruleRule is used as a template to generate sourceCIDRs and proto rules.
			// Each entry in the list is used to generate one INF object, therefore multiple INF objects can be created per test.
			testINFs []testIngressNodeFirewall
			// reachables defines what connectivity we expect
			reachables []reachable
			// protocols are passed to each testINFs to generate INF protocol rules for each protocol
			// For each protocol, a proto rule is generated.
			// This helps to cut down the number of test cases and maximising protocol test coverage.
			protocols []ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType
			// getTestPods returns the pods required during test and a cleanup func()
			getTestPods []func() (*corev1.Pod, func(), error)
		}{
			{
				"block a port with a single rule defining the destinations port",
				[]testIngressNodeFirewall{
					{
						[]string{testInterface},
						[]testRule{
							{
								[]sourceCIDRsEntry{{clientOnePodName, v4SubnetLen, v6SubnetLen}},
								[]func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule{
									func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule {
										return infwutils.GetTransportProtocolBlockPortRule(proto, order, serverOnePort)
									},
								},
							},
						},
					},
				},
				[]reachable{
					{
						clientOnePodName,
						serverOnePodName,
						serverOnePort,
						false,
					},
				},
				transportProtocols,
				[]func() (*corev1.Pod, func(), error){
					func() (*corev1.Pod, func(), error) {
						return transport.GetAndEnsureRunningClient(testclient.Client, clientOnePodName, OperatorNameSpace, clientPodLabel, clientPodLabel,
							serverPodLabel, retryInterval, timeout)
					},
					func() (*corev1.Pod, func(), error) {
						return transport.GetAndEnsureRunningTransportServer(testclient.Client, serverOnePodName, OperatorNameSpace,
							serverPodLabel, serverPodLabel, clientPodLabel, retryInterval, timeout)
					},
				},
			},
			{
				"block a port using a range when multiple source CIDRs exist",
				[]testIngressNodeFirewall{
					{
						[]string{testInterface},
						[]testRule{
							{
								[]sourceCIDRsEntry{{clientOnePodName, v4SubnetLen, v6SubnetLen}, {clientTwoPodName, v4SubnetLen, v6SubnetLen}},
								[]func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule{
									func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule {
										return infwutils.GetTransportProtocolBlockPortRule(proto, order, serverOnePortRange)
									},
								},
							},
						},
					},
				},
				[]reachable{
					{
						clientOnePodName,
						serverOnePodName,
						serverOnePort,
						false,
					},
					{
						clientTwoPodName,
						serverOnePodName,
						serverOnePort,
						false,
					},
				},
				transportProtocols,
				[]func() (*corev1.Pod, func(), error){
					func() (*corev1.Pod, func(), error) {
						return transport.GetAndEnsureRunningClient(testclient.Client, clientOnePodName, OperatorNameSpace, clientPodLabel, clientPodLabel,
							serverPodLabel, retryInterval, timeout)
					},
					func() (*corev1.Pod, func(), error) {
						return transport.GetAndEnsureRunningClient(testclient.Client, clientTwoPodName, OperatorNameSpace, clientPodLabel, clientPodLabel,
							serverPodLabel, retryInterval, timeout)
					},
					func() (*corev1.Pod, func(), error) {
						return transport.GetAndEnsureRunningTransportServer(testclient.Client, serverOnePodName, OperatorNameSpace,
							serverPodLabel, serverPodLabel, clientPodLabel, retryInterval, timeout)
					},
				},
			},
			{
				"block multiple ports",
				[]testIngressNodeFirewall{
					{
						[]string{testInterface},
						[]testRule{
							{
								[]sourceCIDRsEntry{{clientOnePodName, v4SubnetLen, v6SubnetLen}},
								[]func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule{
									func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule {
										return infwutils.GetTransportProtocolBlockPortRule(proto, order, serverOnePort)
									},
									func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule {
										return infwutils.GetTransportProtocolBlockPortRule(proto, order, serverTwoPort)
									},
								},
							},
						},
					},
				},
				[]reachable{
					{
						clientOnePodName,
						serverOnePodName,
						serverOnePort,
						false,
					},
					{
						clientOnePodName,
						serverTwoPodName,
						serverTwoPort,
						false,
					},
				},
				transportProtocols,
				[]func() (*corev1.Pod, func(), error){
					func() (*corev1.Pod, func(), error) {
						return transport.GetAndEnsureRunningClient(testclient.Client, clientOnePodName, OperatorNameSpace, clientPodLabel, clientPodLabel,
							serverPodLabel, retryInterval, timeout)
					},
					func() (*corev1.Pod, func(), error) {
						return transport.GetAndEnsureRunningTransportServer(testclient.Client, serverOnePodName, OperatorNameSpace,
							serverPodLabel, serverPodLabel, clientPodLabel, retryInterval, timeout)
					},
					func() (*corev1.Pod, func(), error) {
						return transport.GetAndEnsureRunningTransportServer(testclient.Client, serverTwoPodName, OperatorNameSpace,
							serverPodLabel, serverPodLabel, clientPodLabel, retryInterval, timeout)
					},
				},
			},
			{
				"block port when rules for a source CIDR are located in multiple IngressNodeFirewall objects",
				[]testIngressNodeFirewall{
					{
						[]string{testInterface},
						[]testRule{
							{
								[]sourceCIDRsEntry{{clientOnePodName, v4SubnetLen, v6SubnetLen}},
								[]func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule{
									func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule {
										return infwutils.GetTransportProtocolBlockPortRule(proto, order, allowedPort)
									},
								},
							},
						},
					},
					{
						[]string{testInterface},
						[]testRule{
							{
								[]sourceCIDRsEntry{{clientOnePodName, v4SubnetLen, v6SubnetLen}},
								[]func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule{
									func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule {
										return infwutils.GetTransportProtocolBlockPortRule(proto, order, serverOnePort)
									},
								},
							},
						},
					},
				},
				[]reachable{
					{
						clientOnePodName,
						serverOnePodName,
						serverOnePort,
						false,
					},
				},
				transportProtocols,
				[]func() (*corev1.Pod, func(), error){
					func() (*corev1.Pod, func(), error) {
						return transport.GetAndEnsureRunningClient(testclient.Client, clientOnePodName, OperatorNameSpace, clientPodLabel, clientPodLabel,
							serverPodLabel, retryInterval, timeout)
					},
					func() (*corev1.Pod, func(), error) {
						return transport.GetAndEnsureRunningTransportServer(testclient.Client, serverOnePodName, OperatorNameSpace,
							serverPodLabel, serverPodLabel, clientPodLabel, retryInterval, timeout)
					},
				},
			},
			{
				"merges transport protocol rules when source CIDRs overlap in multiple IngressNodeFirewalls and the count of source CIDRs for each policy is different",
				// we want to test if we have two identical sourceCIDRs in distinct INFs, but the number of sourceCIDRs is different. For example,
				// in the first INF, we have two sourceCIDRs, and in the second INF, we have one sourceCIDRs. There is an overlap of one sourceCIDR
				// between the two policies. We want to test if we merge them correctly.
				[]testIngressNodeFirewall{
					{
						[]string{testInterface},
						[]testRule{
							{
								[]sourceCIDRsEntry{{clientOnePodName, v4SubnetLen, v6SubnetLen}},
								[]func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule{
									func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule {
										// dummy rule - no effect on test
										return infwutils.GetTransportProtocolBlockPortRule(proto, order, allowedPort)
									},
								},
							},
						},
					},
					// following rule will have higher order value
					{
						[]string{testInterface},
						[]testRule{
							{
								[]sourceCIDRsEntry{{clientOnePodName, v4SubnetLen, v6SubnetLen}, {clientTwoPodName, v4SubnetLen, v6SubnetLen}},
								[]func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule{
									func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule {
										return infwutils.GetTransportProtocolBlockPortRule(proto, order, serverOnePort)
									},
								},
							},
						},
					},
				},
				[]reachable{
					{
						clientOnePodName,
						serverOnePodName,
						serverOnePort,
						false,
					},
					{
						clientTwoPodName,
						serverOnePodName,
						serverOnePort,
						false,
					},
				},
				transportProtocols,
				[]func() (*corev1.Pod, func(), error){
					func() (*corev1.Pod, func(), error) {
						return transport.GetAndEnsureRunningClient(testclient.Client, clientOnePodName, OperatorNameSpace, clientPodLabel, clientPodLabel,
							serverPodLabel, retryInterval, timeout)
					},
					func() (*corev1.Pod, func(), error) {
						return transport.GetAndEnsureRunningClient(testclient.Client, clientTwoPodName, OperatorNameSpace, clientPodLabel, clientPodLabel,
							serverPodLabel, retryInterval, timeout)
					},
					func() (*corev1.Pod, func(), error) {
						return transport.GetAndEnsureRunningTransportServer(testclient.Client, serverOnePodName, OperatorNameSpace,
							serverPodLabel, serverPodLabel, clientPodLabel, retryInterval, timeout)
					},
				},
			},
			{
				"merges multiple IngressNodeFirewalls which contain multiple ingress entries with protocol rules for all protocols",
				[]testIngressNodeFirewall{
					{
						[]string{testInterface},
						[]testRule{
							{
								[]sourceCIDRsEntry{{clientOnePodName, v4SubnetLen, v6SubnetLen}},
								[]func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule{
									func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule {
										if infwutils.IsTransportProtocol(proto) {
											return infwutils.GetTransportProtocolBlockPortRule(proto, order, serverOnePort)
										}
										var echoRequestType uint8
										switch proto {
										case ingressnodefwv1alpha1.ProtocolTypeICMP:
											echoRequestType = 8
										case ingressnodefwv1alpha1.ProtocolTypeICMP6:
											echoRequestType = 128
										default:
											panic("Unsupported protocol")
										}
										return infwutils.GetICMPBlockRule(proto, order, echoRequestType, 0)
									},
								},
							},
							{
								[]sourceCIDRsEntry{{clientTwoPodName, v4SubnetLen, v6SubnetLen}},
								[]func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule{
									func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule {
										if infwutils.IsTransportProtocol(proto) {
											return infwutils.GetTransportProtocolBlockPortRule(proto, order, serverOnePort)
										}
										var echoRequestType uint8
										switch proto {
										case ingressnodefwv1alpha1.ProtocolTypeICMP:
											echoRequestType = 8
										case ingressnodefwv1alpha1.ProtocolTypeICMP6:
											echoRequestType = 128
										default:
											panic("Unsupported protocol")
										}
										return infwutils.GetICMPBlockRule(proto, order, echoRequestType, 0)
									},
								},
							},
						},
					},
					//Second IngressNodeFirewall
					{
						[]string{testInterface},
						[]testRule{
							{
								[]sourceCIDRsEntry{{clientThreePodName, v4SubnetLen, v6SubnetLen}},
								[]func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule{
									func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule {
										if infwutils.IsTransportProtocol(proto) {
											return infwutils.GetTransportProtocolBlockPortRule(proto, order, serverOnePort)
										}
										var echoRequestType uint8
										switch proto {
										case ingressnodefwv1alpha1.ProtocolTypeICMP:
											echoRequestType = 8
										case ingressnodefwv1alpha1.ProtocolTypeICMP6:
											echoRequestType = 128
										default:
											panic("Unexpected protocol")
										}
										return infwutils.GetICMPBlockRule(proto, order, echoRequestType, 0)
									},
								},
							},
							{
								[]sourceCIDRsEntry{{clientFourPodName, v4SubnetLen, v6SubnetLen}},
								[]func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule{
									func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule {
										if infwutils.IsTransportProtocol(proto) {
											return infwutils.GetTransportProtocolBlockPortRule(proto, order, serverOnePort)
										}
										var echoRequestType uint8
										switch proto {
										case ingressnodefwv1alpha1.ProtocolTypeICMP:
											echoRequestType = 8
										case ingressnodefwv1alpha1.ProtocolTypeICMP6:
											echoRequestType = 128
										default:
											panic("Unsupported protocol")
										}
										return infwutils.GetICMPBlockRule(proto, order, echoRequestType, 0)
									},
								},
							},
						},
					},
				},
				[]reachable{
					{
						clientOnePodName,
						serverOnePodName,
						serverOnePort,
						false,
					},
					{
						clientTwoPodName,
						serverOnePodName,
						serverOnePort,
						false,
					},
					{
						clientThreePodName,
						serverOnePodName,
						serverOnePort,
						false,
					},
					{
						clientFourPodName,
						serverOnePodName,
						serverOnePort,
						false,
					},
				},
				append(transportProtocols, icmpProtocols...),
				[]func() (*corev1.Pod, func(), error){
					func() (*corev1.Pod, func(), error) {
						return transport.GetAndEnsureRunningClient(testclient.Client, clientOnePodName, OperatorNameSpace, clientPodLabel, clientPodLabel,
							serverPodLabel, retryInterval, timeout)
					},
					func() (*corev1.Pod, func(), error) {
						return transport.GetAndEnsureRunningClient(testclient.Client, clientTwoPodName, OperatorNameSpace, clientPodLabel, clientPodLabel,
							serverPodLabel, retryInterval, timeout)
					},
					func() (*corev1.Pod, func(), error) {
						return transport.GetAndEnsureRunningClient(testclient.Client, clientThreePodName, OperatorNameSpace, clientPodLabel, clientPodLabel,
							serverPodLabel, retryInterval, timeout)
					},
					func() (*corev1.Pod, func(), error) {
						return transport.GetAndEnsureRunningClient(testclient.Client, clientFourPodName, OperatorNameSpace, clientPodLabel, clientPodLabel,
							serverPodLabel, retryInterval, timeout)
					},
					func() (*corev1.Pod, func(), error) {
						return transport.GetAndEnsureRunningTransportServer(testclient.Client, serverOnePodName, OperatorNameSpace,
							serverPodLabel, serverPodLabel, clientPodLabel, retryInterval, timeout)
					},
				},
			},
			{
				"block port when rules for a source CIDR are located in multiple IngressNodeFirewall objects",
				[]testIngressNodeFirewall{
					{
						[]string{testInterface},
						[]testRule{
							{
								[]sourceCIDRsEntry{{clientOnePodName, v4SubnetLen, v6SubnetLen}},
								[]func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule{
									func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule {
										return infwutils.GetTransportProtocolBlockPortRule(proto, order, allowedPort)
									},
								},
							},
						},
					},
					{
						[]string{testInterface},
						[]testRule{
							{
								[]sourceCIDRsEntry{{clientOnePodName, v4SubnetLen, v6SubnetLen}},
								[]func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule{
									func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule {
										return infwutils.GetTransportProtocolBlockPortRule(proto, order, serverOnePort)
									},
								},
							},
						},
					},
				},
				[]reachable{
					{
						clientOnePodName,
						serverOnePodName,
						serverOnePort,
						false,
					},
				},
				transportProtocols,
				[]func() (*corev1.Pod, func(), error){
					func() (*corev1.Pod, func(), error) {
						return transport.GetAndEnsureRunningClient(testclient.Client, clientOnePodName, OperatorNameSpace, clientPodLabel, clientPodLabel,
							serverPodLabel, retryInterval, timeout)
					},
					func() (*corev1.Pod, func(), error) {
						return transport.GetAndEnsureRunningTransportServer(testclient.Client, serverOnePodName, OperatorNameSpace,
							serverPodLabel, serverPodLabel, clientPodLabel, retryInterval, timeout)
					},
				},
			},
			{
				"merges transport protocol rules when source CIDRs overlap in multiple IngressNodeFirewalls but the number of source CIDRs in each policy is different",
				[]testIngressNodeFirewall{
					{
						[]string{testInterface},
						[]testRule{
							{
								[]sourceCIDRsEntry{{clientOnePodName, v4SubnetLen, v6SubnetLen}},
								[]func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule{
									func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule {
										// dummy rule - no effect on test
										return infwutils.GetTransportProtocolBlockPortRule(proto, order, allowedPort)
									},
								},
							},
						},
					},
					// following rule will have higher order value
					{
						[]string{testInterface},
						[]testRule{
							{
								[]sourceCIDRsEntry{{clientOnePodName, v4SubnetLen, v6SubnetLen}, {clientTwoPodName, v4SubnetLen, v6SubnetLen}},
								[]func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule{
									func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule {
										return infwutils.GetTransportProtocolBlockPortRule(proto, order, serverOnePort)
									},
								},
							},
						},
					},
				},
				[]reachable{
					{
						clientOnePodName,
						serverOnePodName,
						serverOnePort,
						false,
					},
					{
						clientTwoPodName,
						serverOnePodName,
						serverOnePort,
						false,
					},
				},
				transportProtocols,
				[]func() (*corev1.Pod, func(), error){
					func() (*corev1.Pod, func(), error) {
						return transport.GetAndEnsureRunningClient(testclient.Client, clientOnePodName, OperatorNameSpace, clientPodLabel, clientPodLabel,
							serverPodLabel, retryInterval, timeout)
					},
					func() (*corev1.Pod, func(), error) {
						return transport.GetAndEnsureRunningClient(testclient.Client, clientTwoPodName, OperatorNameSpace, clientPodLabel, clientPodLabel,
							serverPodLabel, retryInterval, timeout)
					},
					func() (*corev1.Pod, func(), error) {
						return transport.GetAndEnsureRunningTransportServer(testclient.Client, serverOnePodName, OperatorNameSpace,
							serverPodLabel, serverPodLabel, clientPodLabel, retryInterval, timeout)
					},
				},
			},
			{
				"block ICMP echo request",
				[]testIngressNodeFirewall{
					{
						[]string{testInterface},
						[]testRule{
							{
								[]sourceCIDRsEntry{{clientOnePodName, v4SubnetLen, v6SubnetLen}},
								[]func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule{
									func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule {
										var echoRequestType uint8
										switch proto {
										case ingressnodefwv1alpha1.ProtocolTypeICMP:
											echoRequestType = 8
										case ingressnodefwv1alpha1.ProtocolTypeICMP6:
											echoRequestType = 128
										default:
											panic("Unsupported protocol")
										}
										return infwutils.GetICMPBlockRule(proto, order, echoRequestType, 0)
									},
								},
							},
						},
					},
				},
				[]reachable{
					{
						clientOnePodName,
						serverOnePodName,
						// ICMP protocol only test doesnt require a port
						serverOnePort,
						false,
					},
				},
				icmpProtocols,
				[]func() (*corev1.Pod, func(), error){
					func() (*corev1.Pod, func(), error) {
						return transport.GetAndEnsureRunningClient(testclient.Client, clientOnePodName, OperatorNameSpace, clientPodLabel, clientPodLabel,
							serverPodLabel, retryInterval, timeout)
					},
					func() (*corev1.Pod, func(), error) {
						return transport.GetAndEnsureRunningTransportServer(testclient.Client, serverOnePodName, OperatorNameSpace,
							serverPodLabel, serverPodLabel, clientPodLabel, retryInterval, timeout)
					},
				},
			},
			{
				"non existent interface name doesn't block application of IngressNodeFirewall policy for valid interface",
				[]testIngressNodeFirewall{
					{
						[]string{"doesntexist", testInterface},
						[]testRule{
							{
								[]sourceCIDRsEntry{{clientOnePodName, v4SubnetLen, v6SubnetLen}},
								[]func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule{
									func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule {
										return infwutils.GetTransportProtocolBlockPortRule(proto, order, serverOnePort)
									},
								},
							},
						},
					},
				},
				[]reachable{
					{
						clientOnePodName,
						serverOnePodName,
						serverOnePort,
						false,
					},
				},
				[]ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType{ingressnodefwv1alpha1.ProtocolTypeTCP},
				[]func() (*corev1.Pod, func(), error){
					func() (*corev1.Pod, func(), error) {
						return transport.GetAndEnsureRunningClient(testclient.Client, clientOnePodName, OperatorNameSpace, clientPodLabel, clientPodLabel,
							serverPodLabel, retryInterval, timeout)
					},
					func() (*corev1.Pod, func(), error) {
						return transport.GetAndEnsureRunningTransportServer(testclient.Client, serverOnePodName, OperatorNameSpace,
							serverPodLabel, serverPodLabel, clientPodLabel, retryInterval, timeout)
					},
				},
			},
			{
				"non existent interface name in unrelated IngressNodeFirewall doesn't block application of new IngressNodeFirewalls policies",
				[]testIngressNodeFirewall{
					{
						[]string{"doesntexist"},
						[]testRule{
							{
								[]sourceCIDRsEntry{{clientOnePodName, v4SubnetLen, v6SubnetLen}},
								[]func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule{
									func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule {
										// rule that doesn't affect test
										return infwutils.GetTransportProtocolBlockPortRule(proto, order, allowedPort)
									},
								},
							},
						},
					},
					{
						[]string{testInterface},
						[]testRule{
							{
								[]sourceCIDRsEntry{{clientOnePodName, v4SubnetLen, v6SubnetLen}},
								[]func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule{
									func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule {
										return infwutils.GetTransportProtocolBlockPortRule(proto, order, serverOnePort)
									},
								},
							},
						},
					},
				},
				[]reachable{
					{
						clientOnePodName,
						serverOnePodName,
						serverOnePort,
						false,
					},
				},
				[]ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType{ingressnodefwv1alpha1.ProtocolTypeTCP},
				[]func() (*corev1.Pod, func(), error){
					func() (*corev1.Pod, func(), error) {
						return transport.GetAndEnsureRunningClient(testclient.Client, clientOnePodName, OperatorNameSpace, clientPodLabel, clientPodLabel,
							serverPodLabel, retryInterval, timeout)
					},
					func() (*corev1.Pod, func(), error) {
						return transport.GetAndEnsureRunningTransportServer(testclient.Client, serverOnePodName, OperatorNameSpace,
							serverPodLabel, serverPodLabel, clientPodLabel, retryInterval, timeout)
					},
				},
			},
		}

		BeforeEach(func() {
			config = &ingressnodefwv1alpha1.IngressNodeFirewallConfig{}
			err := infwutils.LoadIngressNodeFirewallConfigFromFile(config, inftestconsts.IngressNodeFirewallConfigCRFile)
			Expect(err).ShouldNot(HaveOccurred())
			config.SetNamespace(OperatorNameSpace)
			config.SetLabels(testArtifactsLabelMap)
			err = infwutils.EnsureIngressNodeFirewallConfigExists(testclient.Client, config, timeout)
			Expect(err).ShouldNot(HaveOccurred())
			//wait for daemonset to be rolled out
			infDaemonSet := &appsv1.DaemonSet{}
			infDaemonSet.SetName("ingress-node-firewall-daemon")
			infDaemonSet.SetNamespace(OperatorNameSpace)
			err = daemonset.WaitForDaemonSetReady(testclient.Client, infDaemonSet, retryInterval, timeout)
			Expect(err).ShouldNot(HaveOccurred())
		})

		AfterEach(func() {
			infwutils.DeleteIngressNodeFirewallConfig(testclient.Client, config, retryInterval, timeout)
		})

		for _, entry := range table {
			entry := entry

			It(entry.it, func() {
				var testINFs []*ingressnodefwv1alpha1.IngressNodeFirewall
				var nodeStateList *ingressnodefwv1alpha1.IngressNodeFirewallNodeStateList
				nextSourceCIDRsOrder := make(map[string]uint32)
				var podNameObj map[string]*corev1.Pod
				var cleanupFn func()
				var err error

				Eventually(func() bool {
					podNameObj, cleanupFn, err = getTestPods(entry.getTestPods)
					if err == nil && podNameObj != nil {
						return true
					}
					return false
				}, time.Minute, time.Second).Should(BeTrue(), "Failed to setup test pods")
				defer cleanupFn()
				// confirm initial connectivity conditions for all protocols defined before IngressNodeFirewall policy application
				for _, reach := range entry.reachables {
					reach := reach
					reachabilityCheck(reach, podNameObj, entry.protocols, true)
				}

				// generate IngressNodeFirewall objects from the templates defined
				for i, testINF := range entry.testINFs {
					testINF := testINF
					inf := &ingressnodefwv1alpha1.IngressNodeFirewall{}
					inf.SetName(fmt.Sprintf("e2e-inf-%d", i))
					inf.SetLabels(testArtifactsLabelMap)
					infwutils.DefineWithWorkerNodeSelector(inf)
					infwutils.DefineWithInterfaces(inf, testINF.interfaces)

					for _, rule := range testINF.testRules {
						rule := rule
						var protoRules []ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule
						var sourceCIDRs []string

						for _, entry := range rule.sourceCIDRsEntries {
							entry := entry
							ips := podNameObj[entry.podName].Status.PodIPs
							if v4Enabled {
								// convert pod IP to correct CIDR. e.g. IP 172.126.1.1 with prefix 8 will result in CIDR 172.0.0.0/8
								v4CIDR := fmt.Sprintf("%s/%s", pods.GetIPV4(ips), entry.v4CIDRPrefix)
								if _, ok := nextSourceCIDRsOrder[v4CIDR]; !ok {
									nextSourceCIDRsOrder[v4CIDR] = 1
								}
								_, cidr, err := net.ParseCIDR(v4CIDR)
								Expect(err).ShouldNot(HaveOccurred())
								sourceCIDRs = append(sourceCIDRs, cidr.String())
							}

							if !isSingleStack && v6Enabled {
								v6CIDR := fmt.Sprintf("%s/%s", pods.GetIPV6(ips), entry.v6CIDRPrefix)
								if _, ok := nextSourceCIDRsOrder[v6CIDR]; !ok {
									nextSourceCIDRsOrder[v6CIDR] = 1
								}
								_, cidr, err := net.ParseCIDR(v6CIDR)
								Expect(err).ShouldNot(HaveOccurred())
								sourceCIDRs = append(sourceCIDRs, cidr.String())
							}
						}
						// find the largest order value seen across all INFs for a given sourceCIDR
						var nextOrder uint32
						for _, sourceCIDR := range sourceCIDRs {
							sourceCIDR := sourceCIDR
							if sourceCIDROrder := nextSourceCIDRsOrder[sourceCIDR]; sourceCIDROrder > nextOrder {
								nextOrder = sourceCIDROrder
							}
						}
						// generate the proto rules for each protocol defined
						for _, protocol := range entry.protocols {
							protocol := protocol
							for _, getProtoRuleFn := range rule.protoRules {
								getProtoRuleFn := getProtoRuleFn
								protoRules = append(protoRules, getProtoRuleFn(protocol, nextOrder))
								nextOrder += 1
							}
						}
						// update the highest order seen for all the source CIDRs encountered
						for _, sourceCIDR := range sourceCIDRs {
							sourceCIDR := sourceCIDR
							nextSourceCIDRsOrder[sourceCIDR] = nextOrder
						}

						inf.Spec.Ingress = append(inf.Spec.Ingress, ingressnodefwv1alpha1.IngressNodeFirewallRules{
							SourceCIDRs:           sourceCIDRs,
							FirewallProtocolRules: protoRules,
						})
					}
					testINFs = append(testINFs, inf)
				}
				// preemptively delete all INFs that we are about to create. If any failure occurs, we want to clean up.
				defer deleteAllTestRules(testINFs, testclient.Client, timeout, nodeStateList)

				nodeStateList = &ingressnodefwv1alpha1.IngressNodeFirewallNodeStateList{}
				for _, testINF := range testINFs {
					testINF := testINF
					By(fmt.Sprintf("Creating Ingress node firewall rules %+v", testINF))
					Eventually(func() error {
						err := infwutils.CreateIngressNodeFirewall(testclient.Client, testINF, timeout)
						return err
					}, timeout, retryInterval).ShouldNot(HaveOccurred())

					Eventually(func() bool {
						fw := &ingressnodefwv1alpha1.IngressNodeFirewall{}
						if err := infwutils.GetIngressNodeFirewallObj(testclient.Client, testINF.Name, fw, timeout); err != nil {
							return false
						}
						if fw.Status.SyncStatus == ingressnodefwv1alpha1.FirewallRulesSyncOK {
							return true
						}
						return false
					}, timeout, retryInterval).Should(BeTrue(), "failed to sync IngressNodeFirewall rule")
				}
				checkNodeStateCreate(testclient.Client, nodeStateList)

				// test INF policy application for all protocols
				for _, reach := range entry.reachables {
					reach := reach
					reachabilityCheck(reach, podNameObj, entry.protocols, reach.connectivity)
				}
				// Make sure all rules are deleted before running next test
				deleteAllTestRules(testINFs, testclient.Client, timeout, nodeStateList)
			})
		}
	})

	Context("Disruption", func() {
		var (
			testName         = "e2e-disruption"
			clientOnePodName = "e2e-disruption-client-one"
			serverOnePodName = "e2e-disruption-server-one"
			serverLabelKey   = "e2e-disruption-server"
			serverLabelValue = ""
			serverPodLabel   = map[string]string{serverLabelKey: serverLabelValue, testArtifactsLabelKey: testArtifactsLabelValue}
			clientLabelKey   = "e2e-disruption-client"
			clientLabelValue = ""
			clientPodLabel   = map[string]string{clientLabelKey: clientLabelValue, testArtifactsLabelKey: testArtifactsLabelValue}
		)

		It("controller manager functions after deletion", func() {
			infConfigs, err := infwutils.GetIngressNodeFirewallConfigs(testclient.Client, timeout)
			Expect(err).ShouldNot(HaveOccurred())
			By("Ensure IngressNodeFirewallConfigs doesn't exist")
			Expect(len(infConfigs)).Should(BeZero())
			By("Delete controller manager pods")
			controllerManagerDeployment, err := deployment.GetDeploymentWithRetry(testclient.Client, OperatorNameSpace,
				inftestconsts.IngressNodeFirewallOperatorDeploymentName, retryInterval, timeout)
			Expect(err).ShouldNot(HaveOccurred())
			Expect(deployment.WaitForDeploymentSetReady(testclient.Client, controllerManagerDeployment, retryInterval,
				timeout)).ShouldNot(HaveOccurred())
			Expect(pods.EnsureDeletedWithLabel(testclient.Client, OperatorNameSpace,
				fmt.Sprintf("control-plane=%s", inftestconsts.IngressNodeFirewallOperatorDeploymentLabel),
				retryInterval, timeout)).ShouldNot(HaveOccurred())
			Expect(deployment.WaitForDeploymentSetReady(testclient.Client, controllerManagerDeployment, retryInterval,
				timeout)).ShouldNot(HaveOccurred())
			By("Ensure controller manager reacts to new IngressNodeFirewallConfig object")
			config := &ingressnodefwv1alpha1.IngressNodeFirewallConfig{}
			err = infwutils.LoadIngressNodeFirewallConfigFromFile(config, inftestconsts.IngressNodeFirewallConfigCRFile)
			Expect(err).ToNot(HaveOccurred())
			config.SetNamespace(OperatorNameSpace)
			Expect(infwutils.EnsureIngressNodeFirewallConfigExists(testclient.Client, config, timeout)).ShouldNot(HaveOccurred())
			defer infwutils.DeleteIngressNodeFirewallConfig(testclient.Client, config, retryInterval, timeout)
			_, err = daemonset.GetDaemonSetWithRetry(testclient.Client, OperatorNameSpace,
				inftestconsts.IngressNodeFirewallDaemonsetName, retryInterval, timeout)
			Expect(err).ShouldNot(HaveOccurred())
			By("Ensure no controller manager restarts occurred")
			restartCount, err := pods.GetPodWithLabelRestartCount(testclient.Client, OperatorNameSpace,
				fmt.Sprintf("control-plane=%s", inftestconsts.IngressNodeFirewallOperatorDeploymentLabel), timeout)
			Expect(err).ShouldNot(HaveOccurred())
			Expect(restartCount).Should(BeZero())
		})

		It("Existing IngresNodeFirewall policy persists after daemon deletion", func() {
			config := &ingressnodefwv1alpha1.IngressNodeFirewallConfig{}
			err := infwutils.LoadIngressNodeFirewallConfigFromFile(config, inftestconsts.IngressNodeFirewallConfigCRFile)
			Expect(err).ToNot(HaveOccurred())
			config.SetNamespace(OperatorNameSpace)
			Expect(infwutils.EnsureIngressNodeFirewallConfigExists(testclient.Client, config, timeout)).ShouldNot(HaveOccurred())
			defer infwutils.DeleteIngressNodeFirewallConfig(testclient.Client, config, retryInterval, timeout)
			daemonSetDeployment, err := daemonset.GetDaemonSetWithRetry(testclient.Client, OperatorNameSpace,
				inftestconsts.IngressNodeFirewallDaemonsetName, retryInterval, timeout)
			Expect(err).ShouldNot(HaveOccurred())
			Expect(daemonset.WaitForDaemonSetReady(testclient.Client, daemonSetDeployment, retryInterval, timeout)).ShouldNot(HaveOccurred())
			clientPod, serverPod, cleanupPodsFn, err := getClientServerTestPods(testclient.Client,
				OperatorNameSpace, clientOnePodName, clientPodLabel, serverOnePodName, serverPodLabel)
			Expect(err).ShouldNot(HaveOccurred())
			defer cleanupPodsFn()
			inf, err := getICMPEchoBlockINF(clientPod, testName, v4Enabled, v6Enabled, isSingleStack)
			Expect(err).ShouldNot(HaveOccurred())
			Expect(infwutils.CreateIngressNodeFirewall(testclient.Client, inf, timeout)).ShouldNot(HaveOccurred())
			By("Confirm connectivity is affected by IngressNodeFirewall policy")
			if v4Enabled {
				Eventually(func() bool {
					return icmp.IsConnectivityOK(testclient.Client, ingressnodefwv1alpha1.ProtocolTypeICMP, clientPod, pods.GetIPV4(serverPod.Status.PodIPs))
				}, timeout, retryInterval).Should(BeFalse())
			}

			if !isSingleStack && v6Enabled {
				Eventually(func() bool {
					return icmp.IsConnectivityOK(testclient.Client, ingressnodefwv1alpha1.ProtocolTypeICMP6, clientPod, pods.GetIPV6(serverPod.Status.PodIPs))
				}, timeout, retryInterval).Should(BeFalse())

			}
			By("Delete node daemon on node where policy will be applied")
			daemonSetPod, err := daemonset.GetDaemonSetOnNode(testclient.Client, OperatorNameSpace, serverPod.Spec.NodeName)
			Expect(err).ShouldNot(HaveOccurred())
			Expect(pods.EnsureDeleted(testclient.Client, daemonSetPod, retryInterval, timeout)).ShouldNot(HaveOccurred())
			Expect(daemonset.WaitForDaemonSetReady(testclient.Client, daemonSetDeployment, retryInterval, timeout)).ShouldNot(HaveOccurred())
			By("Confirm IngressNodeFirewall policy is unaffected after daemon restart")
			if v4Enabled {
				Eventually(func() bool {
					return icmp.IsConnectivityOK(testclient.Client, ingressnodefwv1alpha1.ProtocolTypeICMP, clientPod, pods.GetIPV4(serverPod.Status.PodIPs))
				}, timeout, retryInterval).Should(BeFalse())
			}

			if !isSingleStack && v6Enabled {
				Eventually(func() bool {
					return icmp.IsConnectivityOK(testclient.Client, ingressnodefwv1alpha1.ProtocolTypeICMP6, clientPod, pods.GetIPV6(serverPod.Status.PodIPs))
				}, timeout, retryInterval).Should(BeFalse())

			}
			Expect(infwutils.DeleteIngressNodeFirewall(testclient.Client, inf, timeout)).ShouldNot(HaveOccurred())
		})

		It("IngressNodeFirewall policy is configurable after daemon deletion", func() {
			config := &ingressnodefwv1alpha1.IngressNodeFirewallConfig{}
			err := infwutils.LoadIngressNodeFirewallConfigFromFile(config, inftestconsts.IngressNodeFirewallConfigCRFile)
			Expect(err).ToNot(HaveOccurred())
			config.SetNamespace(OperatorNameSpace)
			Expect(infwutils.EnsureIngressNodeFirewallConfigExists(testclient.Client, config, timeout)).ShouldNot(HaveOccurred())
			defer infwutils.DeleteIngressNodeFirewallConfig(testclient.Client, config, retryInterval, timeout)
			daemonSetDeployment, err := daemonset.GetDaemonSetWithRetry(testclient.Client, OperatorNameSpace,
				inftestconsts.IngressNodeFirewallDaemonsetName, retryInterval, timeout)
			Expect(err).ShouldNot(HaveOccurred())
			Expect(daemonset.WaitForDaemonSetReady(testclient.Client, daemonSetDeployment, retryInterval, timeout)).ShouldNot(HaveOccurred())
			clientPod, serverPod, cleanupPodsFn, err := getClientServerTestPods(testclient.Client,
				OperatorNameSpace, clientOnePodName, clientPodLabel, serverOnePodName, serverPodLabel)
			Expect(err).ShouldNot(HaveOccurred())
			defer cleanupPodsFn()
			inf, err := getICMPEchoBlockINF(clientPod, testName, v4Enabled, v6Enabled, isSingleStack)
			Expect(err).ShouldNot(HaveOccurred())
			Expect(infwutils.CreateIngressNodeFirewall(testclient.Client, inf, timeout)).ShouldNot(HaveOccurred())
			By("Confirm connectivity is affected by IngressNodeFirewall policy")
			if v4Enabled {
				Eventually(func() bool {
					return icmp.IsConnectivityOK(testclient.Client, ingressnodefwv1alpha1.ProtocolTypeICMP, clientPod, pods.GetIPV4(serverPod.Status.PodIPs))
				}, timeout, retryInterval).Should(BeFalse())
			}

			if !isSingleStack && v6Enabled {
				Eventually(func() bool {
					return icmp.IsConnectivityOK(testclient.Client, ingressnodefwv1alpha1.ProtocolTypeICMP6, clientPod, pods.GetIPV6(serverPod.Status.PodIPs))
				}, timeout, retryInterval).Should(BeFalse())

			}
			By("Delete node daemon on node where policy will be applied")
			daemonSetPod, err := daemonset.GetDaemonSetOnNode(testclient.Client, OperatorNameSpace, serverPod.Spec.NodeName)
			Expect(err).ShouldNot(HaveOccurred())
			Expect(pods.EnsureDeleted(testclient.Client, daemonSetPod, retryInterval, timeout)).ShouldNot(HaveOccurred())
			Expect(daemonset.WaitForDaemonSetReady(testclient.Client, daemonSetDeployment, retryInterval, timeout)).ShouldNot(HaveOccurred())
			By("Delete IngressNodeFirewall removes policy")
			Eventually(func() bool {
				err := infwutils.DeleteIngressNodeFirewall(testclient.Client, inf, timeout)
				return errors.IsNotFound(err)
			}, timeout, retryInterval).Should(BeTrue(), "Failed to delete IngressNodeFirewall rules")

			if v4Enabled {
				Eventually(func() bool {
					return icmp.IsConnectivityOK(testclient.Client, ingressnodefwv1alpha1.ProtocolTypeICMP, clientPod, pods.GetIPV4(serverPod.Status.PodIPs))
				}, timeout, retryInterval).Should(BeTrue())
			}

			if !isSingleStack && v6Enabled {
				Eventually(func() bool {
					return icmp.IsConnectivityOK(testclient.Client, ingressnodefwv1alpha1.ProtocolTypeICMP6, clientPod, pods.GetIPV6(serverPod.Status.PodIPs))
				}, timeout, retryInterval).Should(BeTrue())

			}
		})
	})

	Context("Statistics", func() {
		var config *ingressnodefwv1alpha1.IngressNodeFirewallConfig
		var configCRExisted bool

		BeforeEach(func() {
			var err error
			config = &ingressnodefwv1alpha1.IngressNodeFirewallConfig{}
			err = infwutils.LoadIngressNodeFirewallConfigFromFile(config, inftestconsts.IngressNodeFirewallConfigCRFile)
			Expect(err).ToNot(HaveOccurred())
			config.SetNamespace(OperatorNameSpace)
			configCRExisted = true
			err = testclient.Client.Get(context.Background(), goclient.ObjectKey{Namespace: config.Namespace, Name: config.Name}, config)
			if errors.IsNotFound(err) {
				configCRExisted = false
				Expect(testclient.Client.Create(context.Background(), config)).Should(Succeed())
			} else {
				Expect(err).ToNot(HaveOccurred())
			}
		})

		AfterEach(func() {
			if !configCRExisted {
				daemonset, err := testclient.Client.DaemonSets(config.Namespace).Get(context.Background(), inftestconsts.IngressNodeFirewallDaemonsetName, metav1.GetOptions{})
				if err != nil {
					if !errors.IsNotFound(err) {
						Expect(err).ToNot(HaveOccurred())
					}
				} else {
					Expect(daemonset.OwnerReferences).ToNot(BeNil())
					Expect(daemonset.OwnerReferences[0].Kind).To(Equal("IngressNodeFirewallConfig"))
				}
				infwutils.DeleteIngressNodeFirewallConfig(testclient.Client, config, retryInterval, timeout)
			}
		})

		It("should expose at least one endpoint via a daemon metrics service", func() {
			err := wait.PollUntilContextTimeout(context.Background(), 1*time.Second, 10*time.Second, true, func(ctx context.Context) (done bool, err error) {
				endpointSliceList, err := testclient.Client.Endpoints(OperatorNameSpace).List(context.TODO(), metav1.ListOptions{
					LabelSelector: "app=ingress-node-firewall-daemon",
				})

				if err != nil {
					return false, err
				}

				if len(endpointSliceList.Items) == 0 {
					return false, nil
				}

				totalEndpoints := 0
				for _, slice := range endpointSliceList.Items {
					totalEndpoints += len(slice.Subsets)
				}
				if totalEndpoints > 0 {
					return true, nil
				}
				return false, nil
			})

			Expect(err).Should(BeNil())
		})

		It("should expose daemon metrics", func() {
			var (
				inf                              = &ingressnodefwv1alpha1.IngressNodeFirewall{}
				nodeStateList                    = &ingressnodefwv1alpha1.IngressNodeFirewallNodeStateList{}
				clientOnePodName                 = "e2e-inf-daemon-metrics-client-one"
				serverOnePodName                 = "e2e-inf-daemon-metrics-server-one"
				serverLabelKey                   = "e2e-inf-server"
				serverLabelValue                 = ""
				serverPodLabel                   = map[string]string{serverLabelKey: serverLabelValue, testArtifactsLabelKey: testArtifactsLabelValue}
				clientLabelKey                   = "e2e-inf-client"
				clientLabelValue                 = ""
				clientPodLabel                   = map[string]string{clientLabelKey: clientLabelValue, testArtifactsLabelKey: testArtifactsLabelValue}
				clientPod, serverPod             *corev1.Pod
				clientCleanupFn, serverCleanupFn func()
				err                              error
			)
			Eventually(func() error {
				clientPod, clientCleanupFn, err = transport.GetAndEnsureRunningClient(testclient.Client, clientOnePodName, OperatorNameSpace, clientPodLabel, clientPodLabel,
					serverPodLabel, retryInterval, timeout)
				return err
			}, timeout, retryInterval).ShouldNot(HaveOccurred(), "Failed to setup daemon metrics client test pod")
			defer clientCleanupFn()
			sourceCIDRs := make([]string, 0)
			if v4Enabled {
				_, v4CIDR, err := net.ParseCIDR(fmt.Sprintf("%s/%s", pods.GetIPV4(clientPod.Status.PodIPs), v4SubnetLen))
				Expect(err).ShouldNot(HaveOccurred())
				sourceCIDRs = append(sourceCIDRs, v4CIDR.String())
			}
			if !isSingleStack && v6Enabled {
				// no-op if v6 tests are disabled
				_, v6CIDR, err := net.ParseCIDR(fmt.Sprintf("%s/%s", pods.GetIPV6(clientPod.Status.PodIPs), v6SubnetLen))
				Expect(err).ShouldNot(HaveOccurred())
				sourceCIDRs = append(sourceCIDRs, v6CIDR.String())
			}
			Eventually(func() error {
				serverPod, serverCleanupFn, err = transport.GetAndEnsureRunningTransportServer(testclient.Client, serverOnePodName, OperatorNameSpace,
					serverPodLabel, serverPodLabel, clientPodLabel, retryInterval, timeout)
				return err
			}, timeout, retryInterval).ShouldNot(HaveOccurred(), "Failed to setup daemon metrics server test pod")
			defer serverCleanupFn()
			inf.SetName("e2e-inf-daemon-metrics")
			inf.SetLabels(testArtifactsLabelMap)
			infwutils.DefineWithWorkerNodeSelector(inf)
			infwutils.DefineWithInterface(inf, testInterface)
			protoRules := make([]ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule, 0)
			if v4Enabled {
				protoRules = append(protoRules, infwutils.GetICMPBlockRule(ingressnodefwv1alpha1.ProtocolTypeICMP, 1, 8, 0))
			}
			if !isSingleStack && v6Enabled {
				protoRules = append(protoRules, infwutils.GetICMPBlockRule(ingressnodefwv1alpha1.ProtocolTypeICMP6, 2, 128, 0))
			}

			inf.Spec.Ingress = append(inf.Spec.Ingress, ingressnodefwv1alpha1.IngressNodeFirewallRules{
				SourceCIDRs:           sourceCIDRs,
				FirewallProtocolRules: protoRules,
			})

			Eventually(func() error {
				err := testclient.Client.Create(context.Background(), inf)
				return err
			}, timeout, retryInterval).ShouldNot(HaveOccurred())
			Eventually(func() bool {
				fw := &ingressnodefwv1alpha1.IngressNodeFirewall{}
				if err := infwutils.GetIngressNodeFirewallObj(testclient.Client, inf.Name, fw, timeout); err != nil {
					return false
				}
				if fw.Status.SyncStatus == ingressnodefwv1alpha1.FirewallRulesSyncOK {
					return true
				}
				return false
			}, timeout, retryInterval).Should(BeTrue(), "failed to sync IngressNodeFirewall rule")
			checkNodeStateCreate(testclient.Client, nodeStateList)

			defer func() {
				Eventually(func() bool {
					err := testclient.Client.Delete(context.Background(), inf)
					return errors.IsNotFound(err)
				}, timeout, retryInterval).Should(BeTrue(), "Failed destination delete IngressNodeFirewall custom resource")
			}()
			Eventually(func() bool {
				if v4Enabled {
					_, _, err = icmp.PingFromPod(testclient.Client, ingressnodefwv1alpha1.ProtocolTypeICMP, clientPod, pods.GetIPV4(serverPod.Status.PodIPs))
					if err == nil {
						return false
					}
				}

				if !isSingleStack && v6Enabled {
					_, _, err = icmp.PingFromPod(testclient.Client, ingressnodefwv1alpha1.ProtocolTypeICMP6, clientPod, pods.GetIPV6(serverPod.Status.PodIPs))
					if err == nil {
						return false
					}
				}
				return true
			}).WithTimeout(timeout).Should(BeTrue())

			daemonSetPod, err := daemonset.GetDaemonSetOnNode(testclient.Client, OperatorNameSpace, serverPod.Spec.NodeName)
			Expect(err).ShouldNot(HaveOccurred())
			var stdOut, stdError string
			var metrics testutil.Metrics
			err = wait.PollUntilContextTimeout(context.Background(), 1*time.Second, 30*time.Second, true, func(ctx context.Context) (done bool, err error) {
				stdOut, stdError, err = exec.RunExecCommand(testclient.Client, daemonSetPod, "/usr/bin/curl", "127.0.0.1:39301/metrics")
				if err != nil {
					return false, err
				}

				if stdError != "" {
					return false, fmt.Errorf("%s", stdError)
				}

				if stdOut == "" {
					return false, nil
				}
				metrics = testutil.NewMetrics()
				if err = testutil.ParseMetrics(stdOut, &metrics); err != nil {
					return false, fmt.Errorf("failed destination parse metrics: %v", err)
				}

				sample, ok := metrics[infmetrics.MetricINFNamespace+"_"+infmetrics.MetricINFSubsystemNode+"_"+"packet_deny_total"]
				if !ok {
					return false, nil
				}
				if len(sample) == 0 {
					return false, nil
				}

				expectedValue := prommodel.SampleValue(0)
				if v4Enabled {
					expectedValue += 1.0
				}
				if !isSingleStack && v6Enabled {
					expectedValue += 1.0
				}

				if sample[0].Value == expectedValue {
					return true, nil
				}

				return false, nil
			})

			Expect(err).To(BeNil())
			for _, metric := range infmetrics.GetPrometheusStatisticNames() {
				sample, ok := metrics[metric]
				Expect(ok).To(BeTrue())
				Expect(sample.Len() > 0).To(BeTrue())
			}
		})
	})

	// Unit tests will be the primary location to validate the functionality of the webhook, the objective of e2e
	// tests will be to ensure basic functionality of the webhook. Any additional test cases for functionality should
	// be added to unit tests in order to aid test latency.
	Context("Webhook", func() {
		var config *ingressnodefwv1alpha1.IngressNodeFirewallConfig
		var configCRExisted bool

		BeforeEach(func() {
			var err error
			config = &ingressnodefwv1alpha1.IngressNodeFirewallConfig{}
			config.SetLabels(testArtifactsLabelMap)
			err = infwutils.LoadIngressNodeFirewallConfigFromFile(config, inftestconsts.IngressNodeFirewallConfigCRFile)
			Expect(err).ToNot(HaveOccurred())
			config.SetNamespace(OperatorNameSpace)
			configCRExisted = true
			err = testclient.Client.Get(context.Background(), goclient.ObjectKey{Namespace: config.Namespace, Name: config.Name}, config)
			if errors.IsNotFound(err) {
				configCRExisted = false
				Expect(testclient.Client.Create(context.Background(), config)).Should(Succeed())
			} else {
				Expect(err).ToNot(HaveOccurred())
			}
		})

		AfterEach(func() {
			if !configCRExisted {
				daemonset, err := testclient.Client.DaemonSets(config.Namespace).Get(context.Background(), inftestconsts.IngressNodeFirewallDaemonsetName, metav1.GetOptions{})
				if err != nil {
					if !errors.IsNotFound(err) {
						Expect(err).Should(Succeed())
					}
				} else {
					Expect(daemonset.OwnerReferences).ToNot(BeNil())
					Expect(daemonset.OwnerReferences[0].Kind).To(Equal("IngressNodeFirewallConfig"))
				}
				infwutils.DeleteIngressNodeFirewallConfig(testclient.Client, config, retryInterval, timeout)
			}
		})

		It("should allow valid ingressnodefirewall TCP rule", func() {
			inf := &ingressnodefwv1alpha1.IngressNodeFirewall{}
			inf.SetName("e2e-webhook-valid-tcp")
			inf.SetLabels(testArtifactsLabelMap)
			infwutils.DefineWithWorkerNodeSelector(inf)
			infwutils.DefineWithInterface(inf, testInterface)
			infwutils.AppendIngress(inf, "1.1.1.1/32", infwutils.GetTCPRule(1, "40000",
				ingressnodefwv1alpha1.IngressNodeFirewallDeny))
			Expect(testclient.Client.Create(context.Background(), inf)).To(Succeed())
			Expect(infwutils.DeleteIngressNodeFirewall(testclient.Client, inf, timeout)).To(Succeed())
		})

		It("should allow valid ingressnodefirewall UDP rule", func() {
			inf := &ingressnodefwv1alpha1.IngressNodeFirewall{}
			inf.SetName("e2e-webhook-valid-udp")
			inf.SetLabels(testArtifactsLabelMap)
			infwutils.DefineWithWorkerNodeSelector(inf)
			infwutils.DefineWithInterface(inf, testInterface)
			infwutils.AppendIngress(inf, "1.1.1.1/32", infwutils.GetUDPRule(1, "40000",
				ingressnodefwv1alpha1.IngressNodeFirewallDeny))
			Expect(testclient.Client.Create(context.Background(), inf)).To(Succeed())
			Expect(infwutils.DeleteIngressNodeFirewall(testclient.Client, inf, timeout)).To(Succeed())
		})

		It("should allow valid ingressnodefirewall ICMPV4 rule", func() {
			inf := &ingressnodefwv1alpha1.IngressNodeFirewall{}
			inf.SetName("e2e-webhook-valid-icmpv4")
			inf.SetLabels(testArtifactsLabelMap)
			infwutils.DefineWithWorkerNodeSelector(inf)
			infwutils.DefineWithInterface(inf, testInterface)
			infwutils.AppendIngress(inf, "1.1.1.1/32", infwutils.GetICMPV4Rule(1, 0, 1,
				ingressnodefwv1alpha1.IngressNodeFirewallDeny))
			Expect(testclient.Client.Create(context.Background(), inf)).To(Succeed())
			Expect(infwutils.DeleteIngressNodeFirewall(testclient.Client, inf, timeout)).To(Succeed())
		})

		It("should allow valid ingressnodefirewall ICMPV6 rule", func() {
			inf := &ingressnodefwv1alpha1.IngressNodeFirewall{}
			inf.SetName("e2e-webhook-valid-icmpv6")
			inf.SetLabels(testArtifactsLabelMap)
			infwutils.DefineWithWorkerNodeSelector(inf)
			infwutils.DefineWithInterface(inf, testInterface)
			infwutils.AppendIngress(inf, "1:1:1::1/64", infwutils.GetICMPV4Rule(1, 0, 1,
				ingressnodefwv1alpha1.IngressNodeFirewallDeny))
			Expect(testclient.Client.Create(context.Background(), inf)).To(Succeed())
			Expect(infwutils.DeleteIngressNodeFirewall(testclient.Client, inf, timeout)).To(Succeed())
		})

		It("should allow valid ingressnodefirewall SCTP rule", func() {
			inf := &ingressnodefwv1alpha1.IngressNodeFirewall{}
			inf.SetName("e2e-webhook-valid-sctp")
			inf.SetLabels(testArtifactsLabelMap)
			infwutils.DefineWithWorkerNodeSelector(inf)
			infwutils.DefineWithInterface(inf, testInterface)
			infwutils.AppendIngress(inf, "1.1.1.1/32", infwutils.GetSCTPRule(1, "40000",
				ingressnodefwv1alpha1.IngressNodeFirewallDeny))
			Expect(testclient.Client.Create(context.Background(), inf)).To(Succeed())
			Expect(infwutils.DeleteIngressNodeFirewall(testclient.Client, inf, timeout)).To(Succeed())
		})

		It("should block any rules which conflict with failsafe rules", func() {
			for _, tcpFailSafeRule := range failsaferules.GetTCP() {
				inf := &ingressnodefwv1alpha1.IngressNodeFirewall{}
				inf.SetName(fmt.Sprintf("e2e-webhook-block-conflict-%s-tcp", tcpFailSafeRule.GetServiceName()))
				inf.SetLabels(testArtifactsLabelMap)
				infwutils.DefineWithWorkerNodeSelector(inf)
				infwutils.DefineWithInterface(inf, testInterface)
				infwutils.AppendIngress(inf, "1.1.1.1/32", infwutils.GetTCPRule(1, fmt.Sprintf("%d", tcpFailSafeRule.GetPort()),
					ingressnodefwv1alpha1.IngressNodeFirewallDeny))
				Expect(testclient.Client.Create(context.Background(), inf)).ToNot(Succeed())
			}
			for _, udpFailSafeRule := range failsaferules.GetUDP() {
				inf := &ingressnodefwv1alpha1.IngressNodeFirewall{}
				inf.SetName(fmt.Sprintf("e2e-webhook-block-conflict-%s-udp", udpFailSafeRule.GetServiceName()))
				inf.SetLabels(testArtifactsLabelMap)
				infwutils.DefineWithWorkerNodeSelector(inf)
				infwutils.DefineWithInterface(inf, testInterface)
				infwutils.AppendIngress(inf, "1.1.1.1/32", infwutils.GetUDPRule(1, fmt.Sprintf("%d", udpFailSafeRule.GetPort()),
					ingressnodefwv1alpha1.IngressNodeFirewallDeny))
				Expect(testclient.Client.Create(context.Background(), inf)).ToNot(Succeed())
			}
		})
	})
})

func skipProtocol(protocol ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, v6Disabled bool) bool {
	if protocol == ingressnodefwv1alpha1.ProtocolTypeICMP6 && v6Disabled {
		return true
	}
	return false
}

func getTestPods(getTestPodsFns []func() (*corev1.Pod, func(), error)) (map[string]*corev1.Pod, func(), error) {
	var podCleanups []func()
	podNameObj := make(map[string]*corev1.Pod)

	cleanupFn := func() {
		for _, podCleanup := range podCleanups {
			podCleanup()
		}
	}
	for _, podSetupFn := range getTestPodsFns {
		podObj, cleanup, err := podSetupFn()
		if err != nil {
			return nil, nil, err
		}
		podNameObj[podObj.Name] = podObj
		podCleanups = append(podCleanups, cleanup)
	}
	return podNameObj, cleanupFn, nil
}

func isConnectivitySeen(client *testclient.ClientSet, protocol ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType,
	sourcePod *corev1.Pod, sourceIP string, destinationPod *corev1.Pod, destinationIP, destinationPort string, v6 bool) bool {

	serverResultsCh := transport.StartServerForProtocol(testclient.Client, protocol, destinationPod, destinationPort)
	if protocol == ingressnodefwv1alpha1.ProtocolTypeICMP {
		return icmp.IsConnectivityOK(client, protocol, sourcePod, destinationIP)
	} else if protocol == ingressnodefwv1alpha1.ProtocolTypeICMP6 {
		return icmp.IsConnectivityOK(client, protocol, sourcePod, destinationIP)
	} else if infwutils.IsTransportProtocol(protocol) {
		// Connectivity will be confirmed with server output later and expecting server output to contain clients IP.
		_, _, _ = transport.ConnectToPortFromPod(client, protocol, v6, sourcePod, sourceIP, destinationIP, destinationPort)
		serverResult := <-serverResultsCh
		return strings.Contains(serverResult, sourceIP)
	} else {
		panic("Unexpected protocol")
	}
}

func deleteAllTestRules(testINFs []*ingressnodefwv1alpha1.IngressNodeFirewall, client *testclient.ClientSet, timeout time.Duration,
	nodeStateList *ingressnodefwv1alpha1.IngressNodeFirewallNodeStateList) {
	for _, testINF := range testINFs {
		testINF := testINF
		Eventually(func() bool {
			err := infwutils.DeleteIngressNodeFirewall(client, testINF, timeout)
			return errors.IsNotFound(err)
		}, timeout, retryInterval).Should(BeTrue(), "Failed to delete IngressNodeFirewall rules")
	}
}

func reachabilityCheck(reach reachable, podNameObj map[string]*corev1.Pod,
	protocols []ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, isReachable bool) {
	sourcePod := podNameObj[reach.source]
	destinationPod := podNameObj[reach.destination]
	destinationPodNodeName := podNameObj[reach.destination].Spec.NodeName
	for _, protocol := range protocols {
		if skipProtocol(protocol, !v6Enabled) {
			continue
		}
		// v4 tests
		if v4Enabled && protocol != ingressnodefwv1alpha1.ProtocolTypeICMP6 {
			sourcePodV4IP := pods.GetIPV4(sourcePod.Status.PodIPs)
			destinationPodV4IP := pods.GetIPV4(destinationPod.Status.PodIPs)
			dbgMsg := fmt.Sprintf("[IPV4] Check connectivity after applying IngressNodeFirewall rules for protocol %s from pod "+
				"%q/%s to destination pod %q/%s", protocol, reach.source, sourcePodV4IP, reach.destination, destinationPodV4IP)
			if isReachable {
				dbgMsg = fmt.Sprintf("[IPV4] Initial connectivity check for protocol %s from pod "+
					"%q to destination pod %q", protocol, reach.source, reach.destination)
			}
			By(dbgMsg)
			Eventually(func() bool {
				return isConnectivitySeen(testclient.Client, protocol, sourcePod, sourcePodV4IP, destinationPod,
					destinationPodV4IP, reach.port, false)
			}, timeout, retryInterval).Should(Equal(isReachable), "Failed: IPv4 connectivity checks")

			// only expect drop events for dropped / blocked connections
			if !isReachable {
				By("[IPV4] Checking if drop events created")
				var expectedEvent events.TestEvent
				if infwutils.IsICMPProtocol(protocol) {
					//TODO: Here we always expect icmp code and type values for V4. Remove hardcoded icmp code and types to allow test flexibility.
					expectedEvent = events.GetICMPTestEvent(protocol, testInterface, sourcePodV4IP,
						destinationPodV4IP, 0, 8)
				} else if infwutils.IsTransportProtocol(protocol) {
					expectedEvent = events.GetTransportTestEvent(protocol, testInterface, sourcePodV4IP,
						destinationPodV4IP, reach.port)
				}
				Eventually(func() bool {
					result, err := events.DidEventOccur(testclient.Client, OperatorNameSpace,
						destinationPodNodeName, expectedEvent, timeout)
					if err != nil {
						log.Printf("IPv4: failed check for events err %v", err)
					}
					return result
				}, timeout, retryInterval).Should(BeTrue(), "Failed: IPv4 expected drop events didn't happen")
			}
		}

		// v6 tests
		if !isSingleStack && v6Enabled && protocol != ingressnodefwv1alpha1.ProtocolTypeICMP {
			sourcePodV6IP := pods.GetIPV6(sourcePod.Status.PodIPs)
			destinationPodV6IP := pods.GetIPV6(destinationPod.Status.PodIPs)
			dbgMsg := fmt.Sprintf("[IPV6] Check connectivity after applying IngressNodeFirewall rules for protocol %s from pod "+
				"%q/%s to destination pod %q/%s", protocol, reach.source, sourcePodV6IP, reach.destination, destinationPodV6IP)
			if isReachable {
				dbgMsg = fmt.Sprintf("[IPV6] Initial connectivity check for protocol %s from pod "+
					"%q to destination pod %q", protocol, reach.source, reach.destination)
			}
			By(dbgMsg)
			Eventually(func() bool {
				return isConnectivitySeen(testclient.Client, protocol, sourcePod, sourcePodV6IP, destinationPod,
					destinationPodV6IP, reach.port, true)
			}, timeout, retryInterval).Should(Equal(isReachable), "Failed: IPv6 connectivity checks")
			// only expect drop events for dropped / blocked connections
			if !isReachable {
				By("[IPV6] Checking if drop events created")
				var expectedEvent events.TestEvent
				if infwutils.IsICMPProtocol(protocol) {
					//TODO: Here we always expect icmp code and type values for V6. Remove hardcoded icmp code and types to allow test flexibility.
					expectedEvent = events.GetICMPTestEvent(protocol, testInterface, sourcePodV6IP,
						destinationPodV6IP, 0, 128)
				} else if infwutils.IsTransportProtocol(protocol) {
					expectedEvent = events.GetTransportTestEvent(protocol, testInterface, sourcePodV6IP,
						destinationPodV6IP, reach.port)
				}
				Eventually(func() bool {
					result, err := events.DidEventOccur(testclient.Client, OperatorNameSpace,
						destinationPodNodeName, expectedEvent, timeout)
					if err != nil {
						log.Printf("IPv6: failed check for events err %v", err)
					}
					return result
				}, timeout, retryInterval).Should(BeTrue(), "Failed: IPv6 expected drop events didn't happen")
			}
		}
	}
}

func checkNodeStateCreate(client *testclient.ClientSet, nodeStateList *ingressnodefwv1alpha1.IngressNodeFirewallNodeStateList) {
	Eventually(func() bool {
		err := client.List(context.Background(), nodeStateList)
		if err != nil {
			return false
		}
		return len(nodeStateList.Items) == node.GetNumOfNodesWithMatchingLabel(testclient.Client, timeout)
	}, timeout, retryInterval).Should(BeTrue())
}

func getClientServerTestPods(client *testclient.ClientSet, namespace, clientName string, clientLabel map[string]string,
	serverName string, serverLabel map[string]string) (*corev1.Pod, *corev1.Pod, func(), error) {
	var clientPod, serverPod *corev1.Pod
	var clientCleanupFn, serverCleanupFn func()
	var err error

	Eventually(func() bool {
		clientPod, clientCleanupFn, err = transport.GetAndEnsureRunningClient(client, clientName, namespace, clientLabel, clientLabel,
			serverLabel, retryInterval, timeout)
		if err == nil && clientPod != nil {
			return true
		}
		return false
	}, time.Minute, time.Second).Should(BeTrue(), "Failed to setup client test pod")

	Eventually(func() bool {
		serverPod, serverCleanupFn, err = transport.GetAndEnsureRunningTransportServer(client, serverName,
			OperatorNameSpace, serverLabel, serverLabel, clientLabel, retryInterval, timeout)
		if err == nil && serverPod != nil {
			return true
		}
		return false
	}, time.Minute, time.Second).Should(BeTrue(), "Failed to setup server test pod")

	return clientPod, serverPod, func() {
		clientCleanupFn()
		serverCleanupFn()
	}, nil
}

func getPodSourceCIDRs(pod *corev1.Pod, v4, v6, singleStack bool) ([]string, error) {
	sourceCIDRs := make([]string, 0)
	if v4 {
		_, v4CIDR, err := net.ParseCIDR(fmt.Sprintf("%s/%s", pods.GetIPV4(pod.Status.PodIPs), "32"))
		if err != nil {
			return nil, err
		}
		sourceCIDRs = append(sourceCIDRs, v4CIDR.String())
	}
	if !singleStack && v6 {
		_, v6CIDR, err := net.ParseCIDR(fmt.Sprintf("%s/%s", pods.GetIPV6(pod.Status.PodIPs), "128"))
		if err != nil {
			return nil, err
		}
		sourceCIDRs = append(sourceCIDRs, v6CIDR.String())
	}
	return sourceCIDRs, nil
}

func getICMPEchoBlockINF(pod *corev1.Pod, infName string, v4, v6, singleStack bool) (*ingressnodefwv1alpha1.IngressNodeFirewall, error) {
	inf := &ingressnodefwv1alpha1.IngressNodeFirewall{}
	inf.SetName(infName)
	inf.SetLabels(testArtifactsLabelMap)
	infwutils.DefineWithWorkerNodeSelector(inf)
	infwutils.DefineWithInterface(inf, testInterface)
	sourceCIDRs, err := getPodSourceCIDRs(pod, v4, v6, singleStack)
	if err != nil {
		return nil, err
	}
	protoRules := make([]ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule, 0)
	if v4 {
		protoRules = append(protoRules, infwutils.GetICMPBlockRule(ingressnodefwv1alpha1.ProtocolTypeICMP, 1, 8, 0))
	}
	if !singleStack && v6 {
		protoRules = append(protoRules, infwutils.GetICMPBlockRule(ingressnodefwv1alpha1.ProtocolTypeICMP6, 2, 128, 0))
	}
	inf.Spec.Ingress = append(inf.Spec.Ingress, ingressnodefwv1alpha1.IngressNodeFirewallRules{
		SourceCIDRs:           sourceCIDRs,
		FirewallProtocolRules: protoRules,
	})
	return inf, nil
}
