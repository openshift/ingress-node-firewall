package tests

import (
	"context"
	"fmt"
	"log"
	"net"
	"os"
	"strings"
	"time"

	ingressnodefwv1alpha1 "github.com/openshift/ingress-node-firewall/api/v1alpha1"
	"github.com/openshift/ingress-node-firewall/pkg/failsaferules"
	infmetrics "github.com/openshift/ingress-node-firewall/pkg/metrics"
	inftestconsts "github.com/openshift/ingress-node-firewall/test/consts"
	testclient "github.com/openshift/ingress-node-firewall/test/e2e/client"
	"github.com/openshift/ingress-node-firewall/test/e2e/daemonset"
	"github.com/openshift/ingress-node-firewall/test/e2e/events"
	"github.com/openshift/ingress-node-firewall/test/e2e/exec"
	"github.com/openshift/ingress-node-firewall/test/e2e/icmp"
	infwutils "github.com/openshift/ingress-node-firewall/test/e2e/ingress-node-firewall"
	"github.com/openshift/ingress-node-firewall/test/e2e/node"
	"github.com/openshift/ingress-node-firewall/test/e2e/pods"
	"github.com/openshift/ingress-node-firewall/test/e2e/transport"

	. "github.com/onsi/ginkgo"
	. "github.com/onsi/gomega"
	prommodel "github.com/prometheus/common/model"
	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/wait"
	"k8s.io/component-base/metrics/testutil"
	goclient "sigs.k8s.io/controller-runtime/pkg/client"
)

var (
	OperatorNameSpace = inftestconsts.DefaultOperatorNameSpace
	retryInterval     = time.Millisecond * 10
	timeout           = time.Second * 40
	testInterface     = "eth0"
	sctpEnabled       = false
	isSingleStack     = false
	v4Enabled         = false
	v6Enabled         = false
)

// testIngressNodeFirewall represents one IngressNodeFirewall object and is used to generate the sourceCIDRs and protocol
// rules.
type testIngressNodeFirewall struct {
	testRules []testRule
}

// testRule is used as a template to generate sourceCIDRs entries and protocol rules
type testRule struct {
	// sourceCIDRsEntry is used to generate an INFs ingress rule sourceCIDRs. The number of entries equals the number of
	// sourceCIDRs created. It must contain at least one pod name source which IPV4 and IPV6 CIDRs are generated.
	sourceCIDRsEntries []sourceCIDRsEntry
	// protoRules is a list of funcs that return a proto rule for an INFs ingress rule.
	// These funcs serves as templates to generate rules for one or more protocols.
	// The list of protocols passed to the function depends on the test description.
	// Order is generated by the test harness to be unique for a source CIDR.
	protoRules []func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule
}

// sourceCIDRsEntry is used to generate a sourceCIDR for an INF ingress rule
// For example, if a given podName pods IPV4 address ends up being 172.168.1.8 with a v4CIDRPrefix of 24, then the generated
// sourceCIDR for IPV4 will be 172.168.1.0/24. In order to ensure IPV6 test coverage, its mandatory to also define
// v6CIDRPrefix.
type sourceCIDRsEntry struct {
	podName      string
	v4CIDRPrefix string
	v6CIDRPrefix string
}

// reachable is used by the test code to determine what connectivity we expect or not expect.
type reachable struct {
	// source defines the pod name which is the client in all test scenarios. Packets are generated source this client.
	source string
	// destination defines the pod name which is the server in all test scenarios. Packets are terminated for transport protocol
	// test cases. For ICMP protocol test cases, "destination" pod is used to set up networking and the server does nothing.
	destination string
	// port is used only for transport protocol tests and is ignored for ICMP test cases
	port string
	// connectivity informs the test code what connectivity we expect during the test case
	connectivity bool
}

func init() {
	if ns := os.Getenv("OO_INSTALL_NAMESPACE"); len(ns) != 0 {
		OperatorNameSpace = ns
	}
	if iss := os.Getenv("IS_SINGLESTACK"); len(iss) != 0 {
		if strings.ToLower(iss) == "true" {
			isSingleStack = true
		}
	}

	if intf := os.Getenv("NODE_INTERFACE"); len(intf) != 0 {
		testInterface = intf
	}
	if isSCTPEnabled := os.Getenv("ENABLE_SCTP"); len(isSCTPEnabled) != 0 {
		if strings.ToLower(isSCTPEnabled) == "true" {
			log.Println("SCTP tests are enabled")
			sctpEnabled = true
		}
	}

	v4Enabled = node.IPV4NetworkExists(testclient.Client, timeout)
	v6Enabled = node.IPV6NetworkExists(testclient.Client, timeout)
}

var _ = Describe("Ingress Node Firewall", func() {
	var (
		testArtifactsLabelKey    = "e2e-inf-test"
		testArtifactsLabelValue  = ""
		testArtifactsLabelMap    = map[string]string{testArtifactsLabelKey: testArtifactsLabelValue}
		testArtifactsLabelString = fmt.Sprintf("%s=%s", testArtifactsLabelKey, testArtifactsLabelValue)
	)

	// Because we don't fully use BeforeAll / AfterAll to setup/teardown test infrastructure and if an error or interrupt occurs,
	// we ensure a clean cluster using AfterSuite. This normally is a no-op and is only valid when user sends interrupt or test failure.
	AfterSuite(func() {
		Expect(pods.EnsureDeletedWithLabel(testclient.Client, OperatorNameSpace, testArtifactsLabelString, timeout)).Should(Succeed())
		Expect(infwutils.DeleteIngressNodeFirewallsWithLabels(testclient.Client, OperatorNameSpace,
			testArtifactsLabelString, timeout)).Should(Succeed())
	})

	Context(fmt.Sprintf("Ingress"), func() {
		var (
			config             *ingressnodefwv1alpha1.IngressNodeFirewallConfig
			serverOnePort      = "80"
			allowedPort        = "40000"
			serverTwoPort      = "8080"
			serverOnePortRange = "79-81"
			clientOnePodName   = "e2e-inf-client-one"
			clientTwoPodName   = "e2e-inf-client-two"
			clientThreePodName = "e2e-inf-client-three"
			clientFourPodName  = "e2e-inf-client-four"
			serverOnePodName   = "e2e-inf-server-one"
			serverTwoPodName   = "e2e-inf-server-two"
			serverLabelKey     = "e2e-inf-server"
			serverLabelValue   = ""
			serverPodLabel     = map[string]string{serverLabelKey: serverLabelValue, testArtifactsLabelKey: testArtifactsLabelValue}
			clientLabelKey     = "e2e-inf-client"
			clientLabelValue   = ""
			clientPodLabel     = map[string]string{clientLabelKey: clientLabelValue, testArtifactsLabelKey: testArtifactsLabelValue}
			// SCTP is conditional added to this list depending on an environment variable
			transportProtocols = []ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType{ingressnodefwv1alpha1.ProtocolTypeTCP, ingressnodefwv1alpha1.ProtocolTypeUDP}
			icmpProtocols      = []ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType{ingressnodefwv1alpha1.ProtocolTypeICMP}
		)

		if sctpEnabled {
			transportProtocols = append(transportProtocols, ingressnodefwv1alpha1.ProtocolTypeSCTP)
		}

		if !isSingleStack {
			icmpProtocols = append(icmpProtocols, ingressnodefwv1alpha1.ProtocolTypeICMP6)
		}

		// We test IngressNodeFirewall configuration against pod to pod communication in a cluster, that is, our source CIDRs
		// must be a subset of the pod network CIDR.
		// The reason we are testing pod to pod communication, which isn't a typical use case for INF,
		// is to minimise possibility of cluster disruption during test runs, and it also gives us flexibility to create
		// (and disrupt) as many connections as we wish - only limited by the number of pods we can create.
		// For a KinD cluster, pod to pod communication is simple and the pod IPs can be filtered on the primary interface 'eth0'.
		// For OCP, pod IPs are visible on the GENEVE interface (with OVN-Kubernetes as the CNI) or vlan interface (with Openshift-SDN as the CNI).
		// This is where we want to attach our XDP program and perform filtering.
		// For OCP with OVN-Kubernetes as the CNI, the interface name is always 'genev_sys_6081'.
		// Test cases involve a source and destination. For all test cases, firewalling is assumed at the destinations node.
		table := []struct {
			it string
			// testINFs is a list of testRules which represent INF rules. A ruleRule is used as a template to generate sourceCIDRs and proto rules.
			// Each entry in the list is used to generate one INF object, therefore multiple INF objects can be created per test.
			testINFs []testIngressNodeFirewall
			// reachables defines what connectivity we expect
			reachables []reachable
			// protocols are passed to each testINFs to generate INF protocol rules for each protocol
			// For each protocol, a proto rule is generated.
			// This helps to cut down the number of test cases and maximising protocol test coverage.
			protocols []ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType
			// getTestPods returns the pods required during test and a cleanup func()
			getTestPods []func() (*corev1.Pod, func(), error)
		}{
			{
				"block a port with a single rule defining the destinations port",
				[]testIngressNodeFirewall{
					{
						[]testRule{
							{
								[]sourceCIDRsEntry{{clientOnePodName, "32", "128"}},
								[]func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule{
									func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule {
										return infwutils.GetTransportProtocolBlockPortRule(proto, order, serverOnePort)
									},
								},
							},
						},
					},
				},
				[]reachable{
					{
						clientOnePodName,
						serverOnePodName,
						serverOnePort,
						false,
					},
				},
				transportProtocols,
				[]func() (*corev1.Pod, func(), error){
					func() (*corev1.Pod, func(), error) {
						return transport.GetAndEnsureRunningClient(testclient.Client, clientOnePodName, OperatorNameSpace, clientPodLabel, clientPodLabel,
							serverPodLabel, retryInterval, timeout)
					},
					func() (*corev1.Pod, func(), error) {
						return transport.GetAndEnsureRunningTransportServer(testclient.Client, serverOnePodName, serverOnePort, OperatorNameSpace,
							serverPodLabel, serverPodLabel, clientPodLabel, retryInterval, timeout)
					},
				},
			},
			{
				"block a port using a range when multiple source CIDRs exist",
				[]testIngressNodeFirewall{
					{
						[]testRule{
							{
								[]sourceCIDRsEntry{{clientOnePodName, "32", "128"}, {clientTwoPodName, "32", "128"}},
								[]func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule{
									func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule {
										return infwutils.GetTransportProtocolBlockPortRule(proto, order, serverOnePortRange)
									},
								},
							},
						},
					},
				},
				[]reachable{
					{
						clientOnePodName,
						serverOnePodName,
						serverOnePort,
						false,
					},
					{
						clientTwoPodName,
						serverOnePodName,
						serverOnePort,
						false,
					},
				},
				transportProtocols,
				[]func() (*corev1.Pod, func(), error){
					func() (*corev1.Pod, func(), error) {
						return transport.GetAndEnsureRunningClient(testclient.Client, clientOnePodName, OperatorNameSpace, clientPodLabel, clientPodLabel,
							serverPodLabel, retryInterval, timeout)
					},
					func() (*corev1.Pod, func(), error) {
						return transport.GetAndEnsureRunningClient(testclient.Client, clientTwoPodName, OperatorNameSpace, clientPodLabel, clientPodLabel,
							serverPodLabel, retryInterval, timeout)
					},
					func() (*corev1.Pod, func(), error) {
						return transport.GetAndEnsureRunningTransportServer(testclient.Client, serverOnePodName, serverOnePort, OperatorNameSpace,
							serverPodLabel, serverPodLabel, clientPodLabel, retryInterval, timeout)
					},
				},
			},
			{
				"block multiple ports",
				[]testIngressNodeFirewall{
					{
						[]testRule{
							{
								[]sourceCIDRsEntry{{clientOnePodName, "32", "128"}},
								[]func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule{
									func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule {
										return infwutils.GetTransportProtocolBlockPortRule(proto, order, serverOnePort)
									},
									func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule {
										return infwutils.GetTransportProtocolBlockPortRule(proto, order, serverTwoPort)
									},
								},
							},
						},
					},
				},
				[]reachable{
					{
						clientOnePodName,
						serverOnePodName,
						serverOnePort,
						false,
					},
					{
						clientOnePodName,
						serverTwoPodName,
						serverTwoPort,
						false,
					},
				},
				transportProtocols,
				[]func() (*corev1.Pod, func(), error){
					func() (*corev1.Pod, func(), error) {
						return transport.GetAndEnsureRunningClient(testclient.Client, clientOnePodName, OperatorNameSpace, clientPodLabel, clientPodLabel,
							serverPodLabel, retryInterval, timeout)
					},
					func() (*corev1.Pod, func(), error) {
						return transport.GetAndEnsureRunningTransportServer(testclient.Client, serverOnePodName, serverOnePort, OperatorNameSpace,
							serverPodLabel, serverPodLabel, clientPodLabel, retryInterval, timeout)
					},
					func() (*corev1.Pod, func(), error) {
						return transport.GetAndEnsureRunningTransportServer(testclient.Client, serverTwoPodName, serverTwoPort, OperatorNameSpace,
							serverPodLabel, serverPodLabel, clientPodLabel, retryInterval, timeout)
					},
				},
			},
			{
				"block port when rules for a source CIDR are located in multiple IngressNodeFirewall objects",
				[]testIngressNodeFirewall{
					{
						[]testRule{
							{
								[]sourceCIDRsEntry{{clientOnePodName, "32", "128"}},
								[]func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule{
									func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule {
										return infwutils.GetTransportProtocolBlockPortRule(proto, order, allowedPort)
									},
								},
							},
						},
					},
					{
						[]testRule{
							{
								[]sourceCIDRsEntry{{clientOnePodName, "32", "128"}},
								[]func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule{
									func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule {
										return infwutils.GetTransportProtocolBlockPortRule(proto, order, serverOnePort)
									},
								},
							},
						},
					},
				},
				[]reachable{
					{
						clientOnePodName,
						serverOnePodName,
						serverOnePort,
						false,
					},
				},
				transportProtocols,
				[]func() (*corev1.Pod, func(), error){
					func() (*corev1.Pod, func(), error) {
						return transport.GetAndEnsureRunningClient(testclient.Client, clientOnePodName, OperatorNameSpace, clientPodLabel, clientPodLabel,
							serverPodLabel, retryInterval, timeout)
					},
					func() (*corev1.Pod, func(), error) {
						return transport.GetAndEnsureRunningTransportServer(testclient.Client, serverOnePodName, serverOnePort, OperatorNameSpace,
							serverPodLabel, serverPodLabel, clientPodLabel, retryInterval, timeout)
					},
				},
			},
			{
				"merges transport protocol rules when source CIDRs overlap in multiple IngressNodeFirewalls and the count of source CIDRs for each policy is different",
				// we want to test if we have two identical sourceCIDRs in distinct INFs, but the number of sourceCIDRs is different. For example,
				// in the first INF, we have two sourceCIDRs, and in the second INF, we have one sourceCIDRs. There is an overlap of one sourceCIDR
				// between the two policies. We want to test if we merge them correctly.
				[]testIngressNodeFirewall{
					{
						[]testRule{
							{
								[]sourceCIDRsEntry{{clientOnePodName, "32", "128"}},
								[]func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule{
									func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule {
										// dummy rule - no effect on test
										return infwutils.GetTransportProtocolBlockPortRule(proto, order, allowedPort)
									},
								},
							},
						},
					},
					// following rule will have higher order value
					{
						[]testRule{
							{
								[]sourceCIDRsEntry{{clientOnePodName, "32", "128"}, {clientTwoPodName, "32", "128"}},
								[]func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule{
									func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule {
										return infwutils.GetTransportProtocolBlockPortRule(proto, order, serverOnePort)
									},
								},
							},
						},
					},
				},
				[]reachable{
					{
						clientOnePodName,
						serverOnePodName,
						serverOnePort,
						false,
					},
					{
						clientTwoPodName,
						serverOnePodName,
						serverOnePort,
						false,
					},
				},
				transportProtocols,
				[]func() (*corev1.Pod, func(), error){
					func() (*corev1.Pod, func(), error) {
						return transport.GetAndEnsureRunningClient(testclient.Client, clientOnePodName, OperatorNameSpace, clientPodLabel, clientPodLabel,
							serverPodLabel, retryInterval, timeout)
					},
					func() (*corev1.Pod, func(), error) {
						return transport.GetAndEnsureRunningClient(testclient.Client, clientTwoPodName, OperatorNameSpace, clientPodLabel, clientPodLabel,
							serverPodLabel, retryInterval, timeout)
					},
					func() (*corev1.Pod, func(), error) {
						return transport.GetAndEnsureRunningTransportServer(testclient.Client, serverOnePodName, serverOnePort, OperatorNameSpace,
							serverPodLabel, serverPodLabel, clientPodLabel, retryInterval, timeout)
					},
				},
			},
			{
				"merges multiple IngressNodeFirewalls which contain multiple ingress entries with protocol rules for all protocols",
				[]testIngressNodeFirewall{
					{
						[]testRule{
							{
								[]sourceCIDRsEntry{{clientOnePodName, "32", "128"}},
								[]func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule{
									func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule {
										if infwutils.IsTransportProtocol(proto) {
											return infwutils.GetTransportProtocolBlockPortRule(proto, order, serverOnePort)
										}
										var echoRequestType uint8
										switch proto {
										case ingressnodefwv1alpha1.ProtocolTypeICMP:
											echoRequestType = 8
										case ingressnodefwv1alpha1.ProtocolTypeICMP6:
											echoRequestType = 128
										default:
											panic("Unsupported protocol")
										}
										return infwutils.GetICMPBlockRule(proto, order, echoRequestType, 0)
									},
								},
							},
							{
								[]sourceCIDRsEntry{{clientTwoPodName, "32", "128"}},
								[]func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule{
									func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule {
										if infwutils.IsTransportProtocol(proto) {
											return infwutils.GetTransportProtocolBlockPortRule(proto, order, serverOnePort)
										}
										var echoRequestType uint8
										switch proto {
										case ingressnodefwv1alpha1.ProtocolTypeICMP:
											echoRequestType = 8
										case ingressnodefwv1alpha1.ProtocolTypeICMP6:
											echoRequestType = 128
										default:
											panic("Unsupported protocol")
										}
										return infwutils.GetICMPBlockRule(proto, order, echoRequestType, 0)
									},
								},
							},
						},
					},
					//Second IngressNodeFirewall
					{
						[]testRule{
							{
								[]sourceCIDRsEntry{{clientThreePodName, "32", "128"}},
								[]func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule{
									func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule {
										if infwutils.IsTransportProtocol(proto) {
											return infwutils.GetTransportProtocolBlockPortRule(proto, order, serverOnePort)
										}
										var echoRequestType uint8
										switch proto {
										case ingressnodefwv1alpha1.ProtocolTypeICMP:
											echoRequestType = 8
										case ingressnodefwv1alpha1.ProtocolTypeICMP6:
											echoRequestType = 128
										default:
											panic("Unexpected protocol")
										}
										return infwutils.GetICMPBlockRule(proto, order, echoRequestType, 0)
									},
								},
							},
							{
								[]sourceCIDRsEntry{{clientFourPodName, "32", "128"}},
								[]func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule{
									func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule {
										if infwutils.IsTransportProtocol(proto) {
											return infwutils.GetTransportProtocolBlockPortRule(proto, order, serverOnePort)
										}
										var echoRequestType uint8
										switch proto {
										case ingressnodefwv1alpha1.ProtocolTypeICMP:
											echoRequestType = 8
										case ingressnodefwv1alpha1.ProtocolTypeICMP6:
											echoRequestType = 128
										default:
											panic("Unsupported protocol")
										}
										return infwutils.GetICMPBlockRule(proto, order, echoRequestType, 0)
									},
								},
							},
						},
					},
				},
				[]reachable{
					{
						clientOnePodName,
						serverOnePodName,
						serverOnePort,
						false,
					},
					{
						clientTwoPodName,
						serverOnePodName,
						serverOnePort,
						false,
					},
					{
						clientThreePodName,
						serverOnePodName,
						serverOnePort,
						false,
					},
					{
						clientFourPodName,
						serverOnePodName,
						serverOnePort,
						false,
					},
				},
				append(transportProtocols, icmpProtocols...),
				[]func() (*corev1.Pod, func(), error){
					func() (*corev1.Pod, func(), error) {
						return transport.GetAndEnsureRunningClient(testclient.Client, clientOnePodName, OperatorNameSpace, clientPodLabel, clientPodLabel,
							serverPodLabel, retryInterval, timeout)
					},
					func() (*corev1.Pod, func(), error) {
						return transport.GetAndEnsureRunningClient(testclient.Client, clientTwoPodName, OperatorNameSpace, clientPodLabel, clientPodLabel,
							serverPodLabel, retryInterval, timeout)
					},
					func() (*corev1.Pod, func(), error) {
						return transport.GetAndEnsureRunningClient(testclient.Client, clientThreePodName, OperatorNameSpace, clientPodLabel, clientPodLabel,
							serverPodLabel, retryInterval, timeout)
					},
					func() (*corev1.Pod, func(), error) {
						return transport.GetAndEnsureRunningClient(testclient.Client, clientFourPodName, OperatorNameSpace, clientPodLabel, clientPodLabel,
							serverPodLabel, retryInterval, timeout)
					},
					func() (*corev1.Pod, func(), error) {
						return transport.GetAndEnsureRunningTransportServer(testclient.Client, serverOnePodName, serverOnePort, OperatorNameSpace,
							serverPodLabel, serverPodLabel, clientPodLabel, retryInterval, timeout)
					},
				},
			},
			{
				"block port when rules for a source CIDR are located in multiple IngressNodeFirewall objects",
				[]testIngressNodeFirewall{
					{
						[]testRule{
							{
								[]sourceCIDRsEntry{{clientOnePodName, "32", "128"}},
								[]func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule{
									func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule {
										return infwutils.GetTransportProtocolBlockPortRule(proto, order, allowedPort)
									},
								},
							},
						},
					},
					{
						[]testRule{
							{
								[]sourceCIDRsEntry{{clientOnePodName, "32", "128"}},
								[]func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule{
									func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule {
										return infwutils.GetTransportProtocolBlockPortRule(proto, order, serverOnePort)
									},
								},
							},
						},
					},
				},
				[]reachable{
					{
						clientOnePodName,
						serverOnePodName,
						serverOnePort,
						false,
					},
				},
				transportProtocols,
				[]func() (*corev1.Pod, func(), error){
					func() (*corev1.Pod, func(), error) {
						return transport.GetAndEnsureRunningClient(testclient.Client, clientOnePodName, OperatorNameSpace, clientPodLabel, clientPodLabel,
							serverPodLabel, retryInterval, timeout)
					},
					func() (*corev1.Pod, func(), error) {
						return transport.GetAndEnsureRunningTransportServer(testclient.Client, serverOnePodName, serverOnePort, OperatorNameSpace,
							serverPodLabel, serverPodLabel, clientPodLabel, retryInterval, timeout)
					},
				},
			},
			{
				"merges transport protocol rules when source CIDRs overlap in multiple IngressNodeFirewalls but the number of source CIDRs in each policy is different",
				[]testIngressNodeFirewall{
					{
						[]testRule{
							{
								[]sourceCIDRsEntry{{clientOnePodName, "32", "128"}},
								[]func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule{
									func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule {
										// dummy rule - no effect on test
										return infwutils.GetTransportProtocolBlockPortRule(proto, order, allowedPort)
									},
								},
							},
						},
					},
					// following rule will have higher order value
					{
						[]testRule{
							{
								[]sourceCIDRsEntry{{clientOnePodName, "32", "128"}, {clientTwoPodName, "32", "128"}},
								[]func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule{
									func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule {
										return infwutils.GetTransportProtocolBlockPortRule(proto, order, serverOnePort)
									},
								},
							},
						},
					},
				},
				[]reachable{
					{
						clientOnePodName,
						serverOnePodName,
						serverOnePort,
						false,
					},
					{
						clientTwoPodName,
						serverOnePodName,
						serverOnePort,
						false,
					},
				},
				transportProtocols,
				[]func() (*corev1.Pod, func(), error){
					func() (*corev1.Pod, func(), error) {
						return transport.GetAndEnsureRunningClient(testclient.Client, clientOnePodName, OperatorNameSpace, clientPodLabel, clientPodLabel,
							serverPodLabel, retryInterval, timeout)
					},
					func() (*corev1.Pod, func(), error) {
						return transport.GetAndEnsureRunningClient(testclient.Client, clientTwoPodName, OperatorNameSpace, clientPodLabel, clientPodLabel,
							serverPodLabel, retryInterval, timeout)
					},
					func() (*corev1.Pod, func(), error) {
						return transport.GetAndEnsureRunningTransportServer(testclient.Client, serverOnePodName, serverOnePort, OperatorNameSpace,
							serverPodLabel, serverPodLabel, clientPodLabel, retryInterval, timeout)
					},
				},
			},
			{
				"block ICMP echo request",
				[]testIngressNodeFirewall{
					{
						[]testRule{
							{
								[]sourceCIDRsEntry{{clientOnePodName, "32", "128"}},
								[]func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule{
									func(proto ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, order uint32) ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule {
										var echoRequestType uint8
										switch proto {
										case ingressnodefwv1alpha1.ProtocolTypeICMP:
											echoRequestType = 8
										case ingressnodefwv1alpha1.ProtocolTypeICMP6:
											echoRequestType = 128
										default:
											panic("Unsupported protocol")
										}
										return infwutils.GetICMPBlockRule(proto, order, echoRequestType, 0)
									},
								},
							},
						},
					},
				},
				[]reachable{
					{
						clientOnePodName,
						serverOnePodName,
						// ICMP protocol only test doesnt require a port
						serverOnePort,
						false,
					},
				},
				icmpProtocols,
				[]func() (*corev1.Pod, func(), error){
					func() (*corev1.Pod, func(), error) {
						return transport.GetAndEnsureRunningClient(testclient.Client, clientOnePodName, OperatorNameSpace, clientPodLabel, clientPodLabel,
							serverPodLabel, retryInterval, timeout)
					},
					func() (*corev1.Pod, func(), error) {
						return transport.GetAndEnsureRunningTransportServer(testclient.Client, serverOnePodName, serverOnePort, OperatorNameSpace,
							serverPodLabel, serverPodLabel, clientPodLabel, retryInterval, timeout)
					},
				},
			},
		}

		BeforeEach(func() {
			config = &ingressnodefwv1alpha1.IngressNodeFirewallConfig{}
			err := infwutils.LoadIngressNodeFirewallConfigFromFile(config, inftestconsts.IngressNodeFirewallConfigCRFile)
			Expect(err).ShouldNot(HaveOccurred())
			config.SetNamespace(OperatorNameSpace)
			config.SetLabels(testArtifactsLabelMap)
			err = infwutils.EnsureIngressNodeFirewallConfigExists(testclient.Client, config, timeout)
			Expect(err).ShouldNot(HaveOccurred())
			//wait for daemonset to be rolled out
			infDaemonSet := &appsv1.DaemonSet{}
			err = daemonset.WaitForDaemonSetReady(testclient.Client, infDaemonSet, OperatorNameSpace,
				"ingress-node-firewall-daemon", retryInterval, timeout)
			Expect(err).ShouldNot(HaveOccurred())
		})

		AfterEach(func() {
			infwutils.DeleteIngressNodeFirewallConfig(testclient.Client, config, retryInterval, timeout)
		})

		for _, entry := range table {
			entry := entry

			It(entry.it, func() {
				var testINFs []*ingressnodefwv1alpha1.IngressNodeFirewall
				nextSourceCIDRsOrder := make(map[string]uint32)

				podNameObj, cleanupFn, err := getTestPods(entry.getTestPods)
				Expect(err).ShouldNot(HaveOccurred())
				defer cleanupFn()

				// confirm initial connectivity conditions for all protocols defined before IngressNodeFirewall policy application
				for _, reach := range entry.reachables {
					reach := reach
					sourcePod := podNameObj[reach.source]
					destinationPod := podNameObj[reach.destination]

					for _, protocol := range entry.protocols {
						if skipProtocol(protocol, isSingleStack) {
							continue
						}
						// v4 tests
						if v4Enabled && protocol != ingressnodefwv1alpha1.ProtocolTypeICMP6 {
							By(fmt.Sprintf("[IPV4] Confirm connectivity before IngressNodeFirewall policy application for protocol %s from pod "+
								"%q to destination pod %q", protocol, reach.source, reach.destination))
							sourcePodV4IP := pods.GetIPV4(sourcePod.Status.PodIPs)
							destinationPodV4IP := pods.GetIPV4(destinationPod.Status.PodIPs)
							Eventually(func() bool {
								return isConnectivitySeen(testclient.Client, protocol, sourcePod, sourcePodV4IP, destinationPod,
									destinationPodV4IP, reach.port, false)
							}, timeout, retryInterval).Should(BeTrue())
						}
						// v6 tests
						if !isSingleStack && v6Enabled && protocol != ingressnodefwv1alpha1.ProtocolTypeICMP {
							By(fmt.Sprintf("[IPV6] Confirm connectivity before IngressNodeFirewall policy application for protocol %s from pod "+
								"%q to destination pod %q", protocol, reach.source, reach.destination))
							sourcePodV6IP := pods.GetIPV6(sourcePod.Status.PodIPs)
							destinationPodV6IP := pods.GetIPV6(destinationPod.Status.PodIPs)
							Eventually(func() bool {
								return isConnectivitySeen(testclient.Client, protocol, sourcePod, sourcePodV6IP, destinationPod,
									destinationPodV6IP, reach.port, true)
							}, timeout, retryInterval).Should(BeTrue())
						}
					}
				}

				// generate IngressNodeFirewall objects from the templates defined
				for i, testINF := range entry.testINFs {
					inf := &ingressnodefwv1alpha1.IngressNodeFirewall{}
					inf.SetName(fmt.Sprintf("e2e-inf-%d", i))
					inf.SetLabels(testArtifactsLabelMap)
					infwutils.DefineWithWorkerNodeSelector(inf)
					infwutils.DefineWithInterface(inf, testInterface)

					for _, rule := range testINF.testRules {
						var protoRules []ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule
						var sourceCIDRs []string

						for _, entry := range rule.sourceCIDRsEntries {
							ips := podNameObj[entry.podName].Status.PodIPs
							if v4Enabled {
								// convert pod IP to correct CIDR. e.g. IP 172.126.1.1 with prefix 8 will result in CIDR 172.0.0.0/8
								v4CIDR := fmt.Sprintf("%s/%s", pods.GetIPV4(ips), entry.v4CIDRPrefix)
								if _, ok := nextSourceCIDRsOrder[v4CIDR]; !ok {
									nextSourceCIDRsOrder[v4CIDR] = 1
								}
								_, cidr, err := net.ParseCIDR(v4CIDR)
								Expect(err).ShouldNot(HaveOccurred())
								sourceCIDRs = append(sourceCIDRs, cidr.String())
							}

							if !isSingleStack && v6Enabled {
								v6CIDR := fmt.Sprintf("%s/%s", pods.GetIPV6(ips), entry.v6CIDRPrefix)
								if _, ok := nextSourceCIDRsOrder[v6CIDR]; !ok {
									nextSourceCIDRsOrder[v6CIDR] = 1
								}
								_, cidr, err := net.ParseCIDR(v6CIDR)
								Expect(err).ShouldNot(HaveOccurred())
								sourceCIDRs = append(sourceCIDRs, cidr.String())
							}
						}
						// find the largest order value seen across all INFs for a given sourceCIDR
						var nextOrder uint32
						for _, sourceCIDR := range sourceCIDRs {
							if sourceCIDROrder := nextSourceCIDRsOrder[sourceCIDR]; sourceCIDROrder > nextOrder {
								nextOrder = sourceCIDROrder
							}
						}
						// generate the proto rules for each protocol defined
						for _, protocol := range entry.protocols {
							for _, getProtoRuleFn := range rule.protoRules {
								protoRules = append(protoRules, getProtoRuleFn(protocol, nextOrder))
								nextOrder += 1
							}
						}
						// update the highest order seen for all the source CIDRs encountered
						for _, sourceCIDR := range sourceCIDRs {
							nextSourceCIDRsOrder[sourceCIDR] = nextOrder
						}

						inf.Spec.Ingress = append(inf.Spec.Ingress, ingressnodefwv1alpha1.IngressNodeFirewallRules{
							SourceCIDRs:           sourceCIDRs,
							FirewallProtocolRules: protoRules,
						})
					}
					testINFs = append(testINFs, inf)
				}
				// preemptively delete all INFs that we are about to create. If any failure occurs, we want to clean up.
				defer func() {
					for _, testINFs := range testINFs {
						Expect(infwutils.DeleteIngressNodeFirewall(testclient.Client, testINFs, timeout)).Should(Succeed())
					}
				}()

				for _, testINF := range testINFs {
					Expect(infwutils.CreateIngressNodeFirewall(testclient.Client, testINF, timeout)).Should(Succeed())
				}

				// test INF policy application for all protocols
				for _, reach := range entry.reachables {
					reach := reach
					sourcePod := podNameObj[reach.source]
					destinationPod := podNameObj[reach.destination]
					destinationPodNodeName := podNameObj[reach.destination].Spec.NodeName

					for _, protocol := range entry.protocols {
						if skipProtocol(protocol, isSingleStack) {
							continue
						}
						// V4 test
						if v4Enabled && protocol != ingressnodefwv1alpha1.ProtocolTypeICMP6 {
							By(fmt.Sprintf("[IPV4] Confirm IngressNodeFirewall policy application for protocol %s from pod "+
								"%q to destination pod %q", protocol, reach.source, reach.destination))
							sourcePodV4IP := pods.GetIPV4(sourcePod.Status.PodIPs)
							destinationPodV4IP := pods.GetIPV4(destinationPod.Status.PodIPs)
							Eventually(func() bool {
								return isConnectivitySeen(testclient.Client, protocol, sourcePod, sourcePodV4IP, destinationPod,
									destinationPodV4IP, reach.port, false)
							}, timeout, retryInterval).Should(Equal(reach.connectivity))

							// only expect drop events for dropped / blocked connections
							if !reach.connectivity {
								By("[IPV4] Checking if drop events created")
								var expectedEvent events.TestEvent
								if infwutils.IsICMPProtocol(protocol) {
									//TODO: Here we always expect icmp code and type values for V4. Remove hardcoded icmp code and types to allow test flexibility.
									expectedEvent = events.GetICMPTestEvent(protocol, testInterface, sourcePodV4IP,
										destinationPodV4IP, 0, 8)
								} else if infwutils.IsTransportProtocol(protocol) {
									expectedEvent = events.GetTransportTestEvent(protocol, testInterface, sourcePodV4IP,
										destinationPodV4IP, reach.port)
								}
								Eventually(func() bool {
									result, err := events.DidEventOccur(testclient.Client, OperatorNameSpace,
										destinationPodNodeName, expectedEvent, timeout)
									Expect(err).ShouldNot(HaveOccurred())
									return result
								}, timeout, retryInterval).Should(BeTrue())
							}
						}

						// V6 test
						if !isSingleStack && v6Enabled && protocol != ingressnodefwv1alpha1.ProtocolTypeICMP {
							By(fmt.Sprintf("[IPV6] Confirm IngressNodeFirewall policy application for protocol %s from pod "+
								"%q to destination pod %q", protocol, reach.source, reach.destination))
							sourcePodV6IP := pods.GetIPV6(sourcePod.Status.PodIPs)
							destinationPodV6IP := pods.GetIPV6(destinationPod.Status.PodIPs)
							Eventually(func() bool {
								return isConnectivitySeen(testclient.Client, protocol, sourcePod, sourcePodV6IP, destinationPod,
									destinationPodV6IP, reach.port,
									true)
							}, timeout, retryInterval).Should(Equal(reach.connectivity))
							// only expect drop events for dropped / blocked connections
							if !reach.connectivity {
								By("[IPV6] Checking if drop events created")
								var expectedEvent events.TestEvent
								if infwutils.IsICMPProtocol(protocol) {
									//TODO: Here we always expect icmp code and type values for V6. Remove hardcoded icmp code and types to allow test flexibility.
									expectedEvent = events.GetICMPTestEvent(protocol, testInterface, sourcePodV6IP,
										destinationPodV6IP, 0, 128)
								} else if infwutils.IsTransportProtocol(protocol) {
									expectedEvent = events.GetTransportTestEvent(protocol, testInterface, sourcePodV6IP,
										destinationPodV6IP, reach.port)
								}
								Eventually(func() bool {
									result, err := events.DidEventOccur(testclient.Client, OperatorNameSpace,
										destinationPodNodeName, expectedEvent, timeout)
									Expect(err).ShouldNot(HaveOccurred())
									return result
								}, timeout, retryInterval).Should(BeTrue())
							}
						}
					}
				}
			})
		}
	})

	Context("Statistics", func() {
		var config *ingressnodefwv1alpha1.IngressNodeFirewallConfig
		var configCRExisted bool

		BeforeEach(func() {
			var err error
			config = &ingressnodefwv1alpha1.IngressNodeFirewallConfig{}
			err = infwutils.LoadIngressNodeFirewallConfigFromFile(config, inftestconsts.IngressNodeFirewallConfigCRFile)
			Expect(err).ToNot(HaveOccurred())
			config.SetNamespace(OperatorNameSpace)
			configCRExisted = true
			err = testclient.Client.Get(context.Background(), goclient.ObjectKey{Namespace: config.Namespace, Name: config.Name}, config)
			if errors.IsNotFound(err) {
				configCRExisted = false
				Expect(testclient.Client.Create(context.Background(), config)).Should(Succeed())
			} else {
				Expect(err).ToNot(HaveOccurred())
			}
		})

		AfterEach(func() {
			if !configCRExisted {
				daemonset, err := testclient.Client.DaemonSets(config.Namespace).Get(context.Background(), inftestconsts.IngressNodeFirewallDaemonsetName, metav1.GetOptions{})
				if err != nil {
					if !errors.IsNotFound(err) {
						Expect(err).ToNot(HaveOccurred())
					}
				} else {
					Expect(daemonset.OwnerReferences).ToNot(BeNil())
					Expect(daemonset.OwnerReferences[0].Kind).To(Equal("IngressNodeFirewallConfig"))
				}
				infwutils.DeleteIngressNodeFirewallConfig(testclient.Client, config, retryInterval, timeout)
			}
		})

		It("should expose at least one endpoint via a daemon metrics service", func() {
			err := wait.PollImmediate(1*time.Second, 10*time.Second, func() (done bool, err error) {
				endpointSliceList, err := testclient.Client.Endpoints(OperatorNameSpace).List(context.TODO(), metav1.ListOptions{
					LabelSelector: "app=ingress-node-firewall-daemon",
				})

				if err != nil {
					return false, err
				}

				if len(endpointSliceList.Items) == 0 {
					return false, nil
				}

				totalEndpoints := 0
				for _, slice := range endpointSliceList.Items {
					totalEndpoints += len(slice.Subsets)
				}
				if totalEndpoints > 0 {
					return true, nil
				}
				return false, nil
			})

			Expect(err).Should(BeNil())
		})

		It("should expose daemon metrics", func() {
			var (
				inf              = &ingressnodefwv1alpha1.IngressNodeFirewall{}
				clientOnePodName = "e2e-inf-client-one"
				serverOnePodName = "e2e-inf-server-one"
				serverOnePort    = "80"
				serverLabelKey   = "e2e-inf-server"
				serverLabelValue = ""
				serverPodLabel   = map[string]string{serverLabelKey: serverLabelValue, testArtifactsLabelKey: testArtifactsLabelValue}
				clientLabelKey   = "e2e-inf-client"
				clientLabelValue = ""
				clientPodLabel   = map[string]string{clientLabelKey: clientLabelValue, testArtifactsLabelKey: testArtifactsLabelValue}
			)
			clientPod, clientCleanupFn, err := transport.GetAndEnsureRunningClient(testclient.Client, clientOnePodName, OperatorNameSpace, clientPodLabel, clientPodLabel,
				serverPodLabel, retryInterval, timeout)
			Expect(err).ShouldNot(HaveOccurred())
			defer clientCleanupFn()
			sourceCIDRs := make([]string, 0)
			if v4Enabled {
				_, v4CIDR, err := net.ParseCIDR(fmt.Sprintf("%s/%s", pods.GetIPV4(clientPod.Status.PodIPs), "32"))
				Expect(err).ShouldNot(HaveOccurred())
				sourceCIDRs = append(sourceCIDRs, v4CIDR.String())
			}
			if !isSingleStack && v6Enabled {
				// no-op if v6 tests are disabled
				_, v6CIDR, err := net.ParseCIDR(fmt.Sprintf("%s/%s", pods.GetIPV6(clientPod.Status.PodIPs), "128"))
				Expect(err).ShouldNot(HaveOccurred())
				sourceCIDRs = append(sourceCIDRs, v6CIDR.String())
			}
			serverPod, serverCleanupFn, err := transport.GetAndEnsureRunningTransportServer(testclient.Client, serverOnePodName, serverOnePort, OperatorNameSpace,
				serverPodLabel, serverPodLabel, clientPodLabel, retryInterval, timeout)
			Expect(err).ShouldNot(HaveOccurred())
			defer serverCleanupFn()
			inf.SetName("e2e-inf-daemon-metrics")
			inf.SetLabels(testArtifactsLabelMap)
			infwutils.DefineWithWorkerNodeSelector(inf)
			infwutils.DefineWithInterface(inf, testInterface)
			protoRules := make([]ingressnodefwv1alpha1.IngressNodeFirewallProtocolRule, 0)
			if v4Enabled {
				protoRules = append(protoRules, infwutils.GetICMPBlockRule(ingressnodefwv1alpha1.ProtocolTypeICMP, 1, 8, 0))
			}
			if !isSingleStack && v6Enabled {
				protoRules = append(protoRules, infwutils.GetICMPBlockRule(ingressnodefwv1alpha1.ProtocolTypeICMP6, 2, 128, 0))
			}

			inf.Spec.Ingress = append(inf.Spec.Ingress, ingressnodefwv1alpha1.IngressNodeFirewallRules{
				SourceCIDRs:           sourceCIDRs,
				FirewallProtocolRules: protoRules,
			})

			Eventually(func() error {
				err := testclient.Client.Create(context.Background(), inf)
				return err
			}, timeout, retryInterval).Should(Succeed())

			defer Eventually(func() bool {
				err := testclient.Client.Delete(context.Background(), inf)
				return errors.IsNotFound(err)
			}, timeout, retryInterval).Should(BeTrue(), "Failed destination delete IngressNodeFirewall custom resource")
			Eventually(func() bool {
				if v4Enabled {
					_, _, err = icmp.PingFromPod(testclient.Client, ingressnodefwv1alpha1.ProtocolTypeICMP, clientPod, pods.GetIPV4(serverPod.Status.PodIPs))
					if err == nil {
						return false
					}
				}

				if !isSingleStack && v6Enabled {
					_, _, err = icmp.PingFromPod(testclient.Client, ingressnodefwv1alpha1.ProtocolTypeICMP6, clientPod, pods.GetIPV6(serverPod.Status.PodIPs))
					if err == nil {
						return false
					}
				}
				return true
			}).WithTimeout(timeout).Should(BeTrue())

			daemonsetPod, err := daemonset.GetDaemonSetOnNode(testclient.Client, OperatorNameSpace, serverPod.Spec.NodeName)
			Expect(err).ShouldNot(HaveOccurred())
			var stdOut, stdError string
			var metrics testutil.Metrics
			err = wait.PollImmediate(1*time.Second, 60*time.Second, func() (done bool, err error) {
				stdOut, stdError, err = exec.ExecCommand(testclient.Client, daemonsetPod, "/usr/bin/curl", "127.0.0.1:39301/metrics")

				if err != nil {
					return false, err
				}

				if stdError != "" {
					return false, fmt.Errorf("%s", stdError)
				}

				if stdOut == "" {
					return false, nil
				}
				metrics = testutil.NewMetrics()
				if err = testutil.ParseMetrics(stdOut, &metrics); err != nil {
					return false, fmt.Errorf("failed destination parse metrics: %v", err)
				}

				sample, ok := metrics[infmetrics.MetricINFNamespace+"_"+infmetrics.MetricINFSubsystemNode+"_"+"packet_deny_total"]
				if !ok {
					return false, nil
				}
				if len(sample) == 0 {
					return false, nil
				}

				expectedValue := prommodel.SampleValue(0)
				if v4Enabled {
					expectedValue += 1.0
				}
				if !isSingleStack && v6Enabled {
					expectedValue += 1.0
				}

				if sample[0].Value == expectedValue {
					return true, nil
				}

				return false, nil
			})

			Expect(err).To(BeNil())
			for _, metric := range infmetrics.GetPrometheusStatisticNames() {
				sample, ok := metrics[metric]
				Expect(ok).To(BeTrue())
				Expect(sample.Len() > 0).To(BeTrue())
			}
		})
	})

	// Unit tests will be the primary location to validate the functionality of the webhook, the objective of e2e
	// tests will be to ensure basic functionality of the webhook. Any additional test cases for functionality should
	// be added to unit tests in order to aid test latency.
	Context("Webhook", func() {
		var config *ingressnodefwv1alpha1.IngressNodeFirewallConfig
		var configCRExisted bool

		BeforeEach(func() {
			var err error
			config = &ingressnodefwv1alpha1.IngressNodeFirewallConfig{}
			config.SetLabels(testArtifactsLabelMap)
			err = infwutils.LoadIngressNodeFirewallConfigFromFile(config, inftestconsts.IngressNodeFirewallConfigCRFile)
			Expect(err).ToNot(HaveOccurred())
			config.SetNamespace(OperatorNameSpace)
			configCRExisted = true
			err = testclient.Client.Get(context.Background(), goclient.ObjectKey{Namespace: config.Namespace, Name: config.Name}, config)
			if errors.IsNotFound(err) {
				configCRExisted = false
				Expect(testclient.Client.Create(context.Background(), config)).Should(Succeed())
			} else {
				Expect(err).ToNot(HaveOccurred())
			}
		})

		AfterEach(func() {
			if !configCRExisted {
				daemonset, err := testclient.Client.DaemonSets(config.Namespace).Get(context.Background(), inftestconsts.IngressNodeFirewallDaemonsetName, metav1.GetOptions{})
				if err != nil {
					if !errors.IsNotFound(err) {
						Expect(err).Should(Succeed())
					}
				} else {
					Expect(daemonset.OwnerReferences).ToNot(BeNil())
					Expect(daemonset.OwnerReferences[0].Kind).To(Equal("IngressNodeFirewallConfig"))
				}
				infwutils.DeleteIngressNodeFirewallConfig(testclient.Client, config, retryInterval, timeout)
			}
		})

		It("should allow valid ingressnodefirewall TCP rule", func() {
			inf := &ingressnodefwv1alpha1.IngressNodeFirewall{}
			inf.SetName("e2e-webhook-valid-tcp")
			inf.SetLabels(testArtifactsLabelMap)
			infwutils.DefineWithWorkerNodeSelector(inf)
			infwutils.DefineWithInterface(inf, testInterface)
			infwutils.AppendIngress(inf, "1.1.1.1/32", infwutils.GetTCPRule(1, "40000",
				ingressnodefwv1alpha1.IngressNodeFirewallDeny))
			Expect(testclient.Client.Create(context.Background(), inf)).To(Succeed())
			infwutils.DeleteIngressNodeFirewall(testclient.Client, inf, timeout)
		})

		It("should allow valid ingressnodefirewall UDP rule", func() {
			inf := &ingressnodefwv1alpha1.IngressNodeFirewall{}
			inf.SetName("e2e-webhook-valid-udp")
			inf.SetLabels(testArtifactsLabelMap)
			infwutils.DefineWithWorkerNodeSelector(inf)
			infwutils.DefineWithInterface(inf, testInterface)
			infwutils.AppendIngress(inf, "1.1.1.1/32", infwutils.GetUDPRule(1, "40000",
				ingressnodefwv1alpha1.IngressNodeFirewallDeny))
			Expect(testclient.Client.Create(context.Background(), inf)).To(Succeed())
			infwutils.DeleteIngressNodeFirewall(testclient.Client, inf, timeout)
		})

		It("should allow valid ingressnodefirewall ICMPV4 rule", func() {
			inf := &ingressnodefwv1alpha1.IngressNodeFirewall{}
			inf.SetName("e2e-webhook-valid-icmpv4")
			inf.SetLabels(testArtifactsLabelMap)
			infwutils.DefineWithWorkerNodeSelector(inf)
			infwutils.DefineWithInterface(inf, testInterface)
			infwutils.AppendIngress(inf, "1.1.1.1/32", infwutils.GetICMPV4Rule(1, 0, 1,
				ingressnodefwv1alpha1.IngressNodeFirewallDeny))
			Expect(testclient.Client.Create(context.Background(), inf)).To(Succeed())
			infwutils.DeleteIngressNodeFirewall(testclient.Client, inf, timeout)
		})

		It("should allow valid ingressnodefirewall ICMPV6 rule", func() {
			inf := &ingressnodefwv1alpha1.IngressNodeFirewall{}
			inf.SetName("e2e-webhook-valid-icmpv6")
			inf.SetLabels(testArtifactsLabelMap)
			infwutils.DefineWithWorkerNodeSelector(inf)
			infwutils.DefineWithInterface(inf, testInterface)
			infwutils.AppendIngress(inf, "1:1:1::1/64", infwutils.GetICMPV4Rule(1, 0, 1,
				ingressnodefwv1alpha1.IngressNodeFirewallDeny))
			Expect(testclient.Client.Create(context.Background(), inf)).To(Succeed())
			infwutils.DeleteIngressNodeFirewall(testclient.Client, inf, timeout)
		})

		It("should allow valid ingressnodefirewall SCTP rule", func() {
			inf := &ingressnodefwv1alpha1.IngressNodeFirewall{}
			inf.SetName("e2e-webhook-valid-sctp")
			inf.SetLabels(testArtifactsLabelMap)
			infwutils.DefineWithWorkerNodeSelector(inf)
			infwutils.DefineWithInterface(inf, testInterface)
			infwutils.AppendIngress(inf, "1.1.1.1/32", infwutils.GetSCTPRule(1, "40000",
				ingressnodefwv1alpha1.IngressNodeFirewallDeny))
			Expect(testclient.Client.Create(context.Background(), inf)).To(Succeed())
			infwutils.DeleteIngressNodeFirewall(testclient.Client, inf, timeout)
		})

		It("should block any rules which conflict with failsafe rules", func() {
			for _, tcpFailSafeRule := range failsaferules.GetTCP() {
				inf := &ingressnodefwv1alpha1.IngressNodeFirewall{}
				inf.SetName(fmt.Sprintf("e2e-webhook-block-conflict-%s-tcp", tcpFailSafeRule.GetServiceName()))
				inf.SetLabels(testArtifactsLabelMap)
				infwutils.DefineWithWorkerNodeSelector(inf)
				infwutils.DefineWithInterface(inf, testInterface)
				infwutils.AppendIngress(inf, "1.1.1.1/32", infwutils.GetTCPRule(1, fmt.Sprintf("%d", tcpFailSafeRule.GetPort()),
					ingressnodefwv1alpha1.IngressNodeFirewallDeny))
				Expect(testclient.Client.Create(context.Background(), inf)).ToNot(Succeed())
				infwutils.DeleteIngressNodeFirewall(testclient.Client, inf, timeout)
			}
			for _, udpFailSafeRule := range failsaferules.GetUDP() {
				inf := &ingressnodefwv1alpha1.IngressNodeFirewall{}
				inf.SetName(fmt.Sprintf("e2e-webhook-block-conflict-%s-udp", udpFailSafeRule.GetServiceName()))
				inf.SetLabels(testArtifactsLabelMap)
				infwutils.DefineWithWorkerNodeSelector(inf)
				infwutils.DefineWithInterface(inf, testInterface)
				infwutils.AppendIngress(inf, "1.1.1.1/32", infwutils.GetUDPRule(1, fmt.Sprintf("%d", udpFailSafeRule.GetPort()),
					ingressnodefwv1alpha1.IngressNodeFirewallDeny))
				Expect(testclient.Client.Create(context.Background(), inf)).ToNot(Succeed())
				infwutils.DeleteIngressNodeFirewall(testclient.Client, inf, timeout)
			}
		})
	})
})

func skipProtocol(protocol ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType, v6Disabled bool) bool {
	if protocol == ingressnodefwv1alpha1.ProtocolTypeICMP6 && v6Disabled {
		return true
	}
	return false
}

func getTestPods(getTestPods []func() (*corev1.Pod, func(), error)) (map[string]*corev1.Pod, func(), error) {
	var podCleanups []func()
	podNameObj := make(map[string]*corev1.Pod)

	cleanupFn := func() {
		for _, podCleanup := range podCleanups {
			podCleanup()
		}
	}
	for _, podSetupFn := range getTestPods {
		podObj, cleanup, err := podSetupFn()
		if err != nil {
			return nil, nil, err
		}
		podNameObj[podObj.Name] = podObj
		podCleanups = append(podCleanups, cleanup)
	}
	return podNameObj, cleanupFn, nil
}

func isConnectivitySeen(client *testclient.ClientSet, protocol ingressnodefwv1alpha1.IngressNodeFirewallRuleProtocolType,
	sourcePod *corev1.Pod, sourceIP string, destinationPod *corev1.Pod, destinationIP, destinationPort string, v6 bool) bool {

	serverResultsCh := transport.StartServerForProtocol(testclient.Client, protocol, destinationPod, destinationPort)
	if protocol == ingressnodefwv1alpha1.ProtocolTypeICMP {
		return icmp.IsConnectivityOK(client, protocol, sourcePod, destinationIP)
	} else if protocol == ingressnodefwv1alpha1.ProtocolTypeICMP6 {
		return icmp.IsConnectivityOK(client, protocol, sourcePod, destinationIP)
	} else if infwutils.IsTransportProtocol(protocol) {
		// Connectivity will be confirmed with server output later and expecting server output to contain clients IP.
		transport.ConnectToPortFromPod(client, protocol, v6, sourcePod, sourceIP, destinationIP, destinationPort)
		serverResult := <-serverResultsCh
		if strings.Contains(serverResult, sourceIP) {
			return true
		}
		return false
	} else {
		panic("Unexpected protocol")
	}
}
